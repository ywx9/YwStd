/// \file cstddef
/// \copyright (c) 2022 ywx9.com

#pragma once

#include "xtr1common"

#ifdef ywstd_is_exported
extern "C" {
#define offsetof(s, m) ((::size_t)&reinterpret_cast<char const volatile&>((((s*)0)->m)))
}
#endif

export namespace std {

using ptrdiff_t = decltype((int*)0 - (int*)0);
using size_t = decltype(sizeof(0));
using max_align_t = double;
using nullptr_t = decltype(nullptr);

enum class byte : unsigned char {};

template<typename Int> requires is_integral_v<Int>
[[nodiscard]] constexpr byte operator<<(const byte b, const Int i) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(b) << i));
}

template<typename Int> requires is_integral_v<Int>
[[nodiscard]] constexpr byte operator>>(const byte b, const Int i) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(b) >> i));
}

[[nodiscard]] constexpr byte operator|(const byte l, const byte r) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(l) | static_cast<unsigned int>(r)));
}

[[nodiscard]] constexpr byte operator&(const byte l, const byte r) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(l) & static_cast<unsigned int>(r)));
}

[[nodiscard]] constexpr byte operator^(const byte l, const byte r) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(l) ^ static_cast<unsigned int>(r)));
}

[[nodiscard]] constexpr byte operator~(const byte b) noexcept {
  return static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(b)));
}

template<typename Int> requires is_integral_v<Int> //
constexpr byte& operator<<=(byte& b, const Int i) noexcept {
  return b = b << i;
}

template<typename Int> requires is_integral_v<Int> //
constexpr byte& operator>>=(byte& b, const Int i) noexcept {
  return b = b >> i;
}

constexpr byte& operator|=(byte& l, const byte r) noexcept { return l = l | r; }

constexpr byte& operator&=(byte& l, const byte r) noexcept { return l = l & r; }

constexpr byte& operator^=(byte& l, const byte r) noexcept { return l = l ^ r; }

template<typename Int> requires is_integral_v<Int> //
[[nodiscard]] constexpr Int to_integer(const byte b) noexcept {
  return static_cast<Int>(b);
}
}
