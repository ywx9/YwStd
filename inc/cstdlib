/// \file cstdlib
/// \copyright (c) 2022 ywx9.com

#pragma once

#if ywstd_is_exported
extern "C" {

#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
#define RAND_MAX 0x7fff
#define MB_CUR_MAX ___mb_cur_max_func()
int __cdecl ___mb_cur_max_func();

struct div_t {
  int quot, rem;
};

struct ldiv_t {
  long quot, rem;
};

struct lldiv_t {
  long long quot, rem;
};

[[noreturn]] void __cdecl exit(int);
[[noreturn]] void __cdecl _Exit(int);
[[noreturn]] void __cdecl quick_exit(int);
[[noreturn]] void __cdecl abort();
int __cdecl atexit(void(__cdecl*)());
int __cdecl at_quick_exit(void(__cdecl*)());
int __cdecl system(const char*);
char* __cdecl getenv(const char*);

void* __cdecl malloc(size_t);
void* __cdecl calloc(size_t, size_t);
void* __cdecl realloc(void*, size_t);
void __cdecl free(void*);

int __cdecl atoi(const char*);
long __cdecl atol(const char*);
long long __cdecl atoll(const char*);
double __cdecl atof(const char*);
long __cdecl strtol(const char*, char**, int);
unsigned long __cdecl strtoul(const char*, char**, int);
long long __cdecl strtoll(const char*, char**, int);
unsigned long long __cdecl strtoull(const char*, char**, int);
float __cdecl strtof(const char*, char**);
double __cdecl strtod(const char*, char**);
long double __cdecl strtold(const char*, char**);

int __cdecl mblen(const char*, size_t);
int __cdecl mbtowc(wchar_t*, const char*, size_t);
int __cdecl wctomb(char*, wchar_t);
size_t __cdecl mbstowcs(wchar_t*, const char*, size_t);
size_t __cdecl wcstombs(char*, const wchar_t*, size_t);

int __cdecl rand();
void __cdecl srand(unsigned int);
void __cdecl qsort(void*, size_t, size_t, int(__cdecl*)(const void*, const void*));
void* __cdecl bsearch(const void*, const void*, size_t, size_t, int(__cdecl*)(const void*, const void*));
int __cdecl abs(int);
long __cdecl labs(long);
long long __cdecl llabs(long long);
div_t __cdecl div(int, int);
ldiv_t __cdecl ldiv(long, long);
lldiv_t __cdecl lldiv(long long, long long);
}
#endif

export namespace std {

using ::div_t;
using ::ldiv_t;
using ::lldiv_t;

////////////////////////////////////////////////////////////////////////////////
// PROCESS CONTROL

[[noreturn]] inline void exit(int status) { ::exit(status); }
[[noreturn]] inline void _Exit(int status) { ::_Exit(status); }
[[noreturn]] inline void quick_exit(int status) { ::quick_exit(status); }
[[noreturn]] inline void abort() { ::abort(); }
inline int atexit(void(__cdecl* func)()) { return ::atexit(func); }
inline int at_quick_exit(void(__cdecl* func)()) { return ::at_quick_exit(func); }
inline int system(const char* command) { return ::system(command); }
inline char* getenv(const char* name) { return ::getenv(name); }

////////////////////////////////////////////////////////////////////////////////
// MEMORY MANAGEMENT

inline void* malloc(size_t size) { return ::malloc(size); }
inline void* calloc(size_t num, size_t size) { return ::calloc(num, size); }
inline void* realloc(void* ptr, size_t size) { return ::realloc(ptr, size); }
inline void free(void* ptr) { ::free(ptr); }

////////////////////////////////////////////////////////////////////////////////
// NUMERIC STRING CONVERSION

inline int atoi(const char* str) { return ::atoi(str); }
inline long atol(const char* str) { return ::atol(str); }
inline long long atoll(const char* str) { return ::atoll(str); }
inline double atof(const char* str) { return ::atof(str); }
inline long strtol(const char* str, char** endptr, int base) { return ::strtol(str, endptr, base); }
inline unsigned long strtoul(const char* str, char** endptr, int base) { return ::strtoul(str, endptr, base); }
inline long long strtoll(const char* str, char** endptr, int base) { return ::strtoll(str, endptr, base); }
inline unsigned long long strtoull(const char* str, char** endptr, int base) { return ::strtoull(str, endptr, base); }
inline float strtof(const char* str, char** endptr) { return ::strtof(str, endptr); }
inline double strtod(const char* str, char** endptr) { return ::strtod(str, endptr); }
inline long double strtold(const char* str, char** endptr) { return ::strtold(str, endptr); }

////////////////////////////////////////////////////////////////////////////////
// WIDE STRING MANIPULATION

inline int mblen(const char* s, size_t n) { return ::mblen(s, n); }
inline int mbtowc(wchar_t* pwc, const char* s, size_t n) { return ::mbtowc(pwc, s, n); }
inline int wctomb(char* s, wchar_t wc) { return ::wctomb(s, wc); }
inline size_t mbstowcs(wchar_t* pwcs, const char* s, size_t n) { return ::mbstowcs(pwcs, s, n); }
inline size_t wcstombs(char* s, const wchar_t* pwcs, size_t n) { return ::wcstombs(s, pwcs, n); }

////////////////////////////////////////////////////////////////////////////////
// MISCELLANEOUS ALGORITHMS AND MATH

inline int rand() { return ::rand(); }
inline void srand(unsigned int seed) { ::srand(seed); }
inline void qsort(void* base, size_t num, size_t size, int(__cdecl* compare)(const void*, const void*)) {
  ::qsort(base, num, size, compare);
}
inline void* bsearch(const void* key, const void* base, size_t num, size_t size,
                     int(__cdecl* compare)(const void*, const void*)) {
  return ::bsearch(key, base, num, size, compare);
}

constexpr int abs(int i) {
  if (!__builtin_is_constant_evaluated()) return ::abs(i);
  else return i < 0 ? -i : i;
}

constexpr long labs(long i) {
  if (!__builtin_is_constant_evaluated()) return ::labs(i);
  else return i < 0 ? -i : i;
}

constexpr long long llabs(long long i) {
  if (!__builtin_is_constant_evaluated()) return ::llabs(i);
  else return i < 0 ? -i : i;
}

constexpr long abs(long i) { return std::labs(i); }
constexpr long long abs(long long i) { return std::llabs(i); }

constexpr div_t div(int num, int den) {
  if (!__builtin_is_constant_evaluated()) return ::div(num, den);
  else return {num / den, num % den};
}

constexpr ldiv_t ldiv(long num, long den) {
  if (!__builtin_is_constant_evaluated()) return ::ldiv(num, den);
  else return {num / den, num % den};
}

constexpr lldiv_t lldiv(long long num, long long den) {
  if (!__builtin_is_constant_evaluated()) return ::lldiv(num, den);
  else return {num / den, num % den};
}

constexpr ldiv_t div(long num, long den) { return std::ldiv(num, den); }
constexpr lldiv_t div(long long num, long long den) { return std::lldiv(num, den); }
}
