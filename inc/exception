/// \file exception
/// \copyright (c) 2022 ywx9.com

#pragma once

#include "cstdlib"
#include "type_traits"
#include "yvals.h"

#if ywstd_is_exported
extern "C" {
using terminate_handler = void(__cdecl*)();
[[noreturn]] void __cdecl abort();
[[noreturn]] void __cdecl terminate() throw();
terminate_handler __cdecl set_terminate(terminate_handler) throw();
terminate_handler __cdecl _get_terminate();
struct __std_exception_data {
  const char* _What;
  bool _DoFree;
};
void __cdecl __std_exception_copy(const __std_exception_data*, __std_exception_data*);
void __cdecl __std_exception_destroy(__std_exception_data*);
}
extern "C++" {
void __cdecl __ExceptionPtrCreate(void*) noexcept;
void __cdecl __ExceptionPtrDestroy(void*) noexcept;
void __cdecl __ExceptionPtrCopy(void*, const void*) noexcept;
void __cdecl __ExceptionPtrAssign(_Inout_ void*, const void*) noexcept;
bool __cdecl __ExceptionPtrCompare(const void*, const void*) noexcept;
bool __cdecl __ExceptionPtrToBool(const void*) noexcept;
void __cdecl __ExceptionPtrSwap(void*, void*) noexcept;
void __cdecl __ExceptionPtrCurrentException(void*) noexcept;
[[noreturn]] void __cdecl __ExceptionPtrRethrow(const void*);
void __cdecl __ExceptionPtrCopyException(void*, const void*, const void*) noexcept;
}
#endif

export namespace std {

export extern "C++" [[nodiscard]] int __cdecl uncaught_exceptions() noexcept;

class exception {
  __std_exception_data _data{};
public:
  virtual ~exception() noexcept { __std_exception_destroy(&_data); }
  exception() = default;
  explicit exception(const char* const s) noexcept {
    auto d = __std_exception_data{s, true};
    __std_exception_copy(&d, &_data);
  }
  exception(const char* const s, int) noexcept { _data._What = s; }
  exception(exception const& e) noexcept { __std_exception_copy(&e._data, &_data); }
  exception& operator=(exception const& e) noexcept {
    if (this == &e) return *this;
    __std_exception_destroy(&_data);
    __std_exception_copy(&e._data, &_data);
    return *this;
  }
  [[nodiscard]] virtual const char* what() const { return _data._What ? _data._What : "Unknown exception"; }
};

class bad_exception : public exception {
public:
  bad_exception() noexcept : exception("bad exception", 1) {}
};

class bad_alloc : public exception {
  friend class bad_array_new_length;
  bad_alloc(const char* const _Message) noexcept : exception(_Message, 1) {}
public:
  bad_alloc() noexcept : exception("bad allocation", 1) {}
};

class bad_array_new_length : public bad_alloc {
public:
  bad_array_new_length() noexcept : bad_alloc("bad array new length") {}
};

using terminate_handler = void(__cdecl*)();
inline terminate_handler get_terminate() noexcept { return ::_get_terminate(); }
inline terminate_handler set_terminate(terminate_handler f) noexcept { return ::set_terminate(f); }
[[noreturn]] inline void terminate() noexcept { ::terminate(); }

export class exception_ptr {
  void *_Data1{}, *_Data2{};
public:
  ~exception_ptr() noexcept { __ExceptionPtrDestroy(this); }
  exception_ptr() noexcept { __ExceptionPtrCreate(this); }
  exception_ptr(nullptr_t) noexcept { __ExceptionPtrCreate(this); }
  exception_ptr(const exception_ptr& _Rhs) noexcept { __ExceptionPtrCopy(this, &_Rhs); }
  exception_ptr& operator=(const exception_ptr& _Rhs) noexcept { return __ExceptionPtrAssign(this, &_Rhs), *this; }
  exception_ptr& operator=(nullptr_t) noexcept {
    exception_ptr _Ptr;
    return __ExceptionPtrAssign(this, &_Ptr), *this;
  }
  explicit operator bool() const noexcept { return __ExceptionPtrToBool(this); }
  static exception_ptr _Copy_exception(void* _Except, const void* _Ptr) {
    exception_ptr _Retval;
    if (!_Ptr) return _Retval;
    __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
    return _Retval;
  }
  friend void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept { __ExceptionPtrSwap(&_Lhs, &_Rhs); }
  [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
    return __ExceptionPtrCompare(&_Lhs, &_Rhs);
  }
  [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept { return !_Lhs; }
};

export [[nodiscard]] inline exception_ptr current_exception() noexcept {
  exception_ptr _Retval;
  __ExceptionPtrCurrentException(&_Retval);
  return _Retval;
}

export [[noreturn]] inline void rethrow_exception(exception_ptr ep) { __ExceptionPtrRethrow(&ep); }

template<class _Ex> void* __GetExceptionInfo(_Ex);

export template<class _Ex> [[nodiscard]] exception_ptr make_exception_ptr(_Ex _Except) noexcept {
  return exception_ptr::_Copy_exception(std::addressof(_Except), __GetExceptionInfo(_Except));
}

export class nested_exception {
  exception_ptr _ep;
public:
  virtual ~nested_exception() noexcept {}
  nested_exception() noexcept : _ep(std::current_exception()) {}
  nested_exception(const nested_exception&) noexcept = default;
  nested_exception& operator=(const nested_exception&) noexcept = default;
  [[noreturn]] void rethrow_nested() const { _ep ? std::rethrow_exception(_ep) : std::terminate(); }
  [[nodiscard]] exception_ptr nested_ptr() const noexcept { return _ep; }
};

template<class _Uty> struct _With_nested_v2 : _Uty, nested_exception { // glue user exception to nested_exception
  template<class _Ty> explicit _With_nested_v2(_Ty&& _Arg)
    : _Uty(std::forward<_Ty>(_Arg)), nested_exception() {} // store user exception and current_exception()
};

export template<class _Ty> [[noreturn]] void throw_with_nested(_Ty&& _Arg) {
  using _Uty = decay_t<_Ty>;
  if constexpr (is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>) {
    // throw user exception glued to nested_exception
    _THROW(_With_nested_v2<_Uty>(std::forward<_Ty>(_Arg)));
  } else {
    // throw user exception by itself
    _THROW(std::forward<_Ty>(_Arg));
  }
}

export template<typename T> void rethrow_if_nested(const T& a) {
  if constexpr (is_polymorphic_v<T> &&
                (!is_base_of_v<nested_exception, T> || is_convertible_v<T*, nested_exception*>)) {
    const auto ne = dynamic_cast<const nested_exception*>(std::addressof(a));
    if (ne) { ne->rethrow_nested(); }
  }
}

export class [[nodiscard]] bad_variant_access : public exception {
public:
  bad_variant_access() noexcept = default;
  [[nodiscard]] const char* __CLR_OR_THIS_CALL what() const noexcept override { return "bad variant access"; }
};
}
