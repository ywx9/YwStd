/// \file cmath
// cmath standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#ifndef _CMATH_
#define _CMATH_
#include "yvals.h"
#if _STL_COMPILER_PREPROCESSOR

#include "xtr1common"

#if !defined(__clang__) && !defined(__CUDACC__) && !defined(__INTEL_COMPILER) && \
  !defined(_M_CEE) // TRANSITION, VSO-1663104
#define _HAS_CMATH_INTRINSICS 1
#else // ^^^ intrinsics available / intrinsics unavailable vvv
#define _HAS_CMATH_INTRINSICS 0
#endif // ^^^ intrinsics unavailable ^^^

#if _HAS_CMATH_INTRINSICS
#include "intrin0.h"
#endif // _HAS_CMATH_INTRINSICS

#if _HAS_CXX20
#include "type_traits"
#endif // _HAS_CXX20

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_CRT_BEGIN_C_HEADER

#ifndef __assembler
// Definition of the _exception struct, which is passed to the matherr function
// when a floating point exception is detected:
struct _exception {
  int type;      // exception type - see below
  char* name;    // name of function where error occurred
  double arg1;   // first argument to function
  double arg2;   // second argument (if any) to function
  double retval; // value to be returned by function
};

// Definition of the _complex struct to be used by those who use the complex
// functions and want type checking.
#ifndef _COMPLEX_DEFINED
#define _COMPLEX_DEFINED

struct _complex {
  double x, y; // real and imaginary parts
};

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES && !defined __cplusplus
// Non-ANSI name for compatibility
#define complex _complex
#endif
#endif
#endif // __assembler

// On x86, when not using /arch:SSE2 or greater, floating point operations
// are performed using the x87 instruction set and FLT_EVAL_METHOD is 2.
// (When /fp:fast is used, floating point operations may be consistent, so
// we use the default types.)
#if defined _M_IX86 && _M_IX86_FP < 2 && !defined _M_FP_FAST
typedef long double float_t;
typedef long double double_t;
#else
typedef float float_t;
typedef double double_t;
#endif

// Constant definitions for the exception type passed in the _exception struct
#define _DOMAIN 1    // argument domain error
#define _SING 2      // argument singularity
#define _OVERFLOW 3  // overflow range error
#define _UNDERFLOW 4 // underflow range error
#define _TLOSS 5     // total loss of precision
#define _PLOSS 6     // partial loss of precision

// Definitions of _HUGE and HUGE_VAL - respectively the XENIX and ANSI names
// for a value returned in case of error by a number of the floating point
// math routines.
#ifndef __assembler
#ifndef _M_CEE_PURE
extern double const _HUGE;
#else
double const _HUGE = System::Double::PositiveInfinity;
#endif
#endif

#ifndef _HUGE_ENUF
#define _HUGE_ENUF 1e+300 // _HUGE_ENUF*_HUGE_ENUF must overflow
#endif

#define INFINITY ((float)(_HUGE_ENUF * _HUGE_ENUF))
#define HUGE_VAL ((double)INFINITY)
#define HUGE_VALF ((float)INFINITY)
#define HUGE_VALL ((long double)INFINITY)
#ifndef _UCRT_NEGATIVE_NAN
// This operation creates a negative NAN adding a - to make it positive
#define NAN (-(float)(INFINITY * 0.0F))
#else
// Keep this for backwards compatibility
#define NAN ((float)(INFINITY * 0.0F))
#endif

#define _DENORM (-2)
#define _FINITE (-1)
#define _INFCODE 1
#define _NANCODE 2

#define FP_INFINITE _INFCODE
#define FP_NAN _NANCODE
#define FP_NORMAL _FINITE
#define FP_SUBNORMAL _DENORM
#define FP_ZERO 0

#define _C2 1 // 0 if not 2's complement
#define FP_ILOGB0 (-0x7fffffff - _C2)
#define FP_ILOGBNAN 0x7fffffff

#define MATH_ERRNO 1
#define MATH_ERREXCEPT 2
#define math_errhandling (MATH_ERRNO | MATH_ERREXCEPT)

// Values for use as arguments to the _fperrraise function
#define _FE_DIVBYZERO 0x04
#define _FE_INEXACT 0x20
#define _FE_INVALID 0x01
#define _FE_OVERFLOW 0x08
#define _FE_UNDERFLOW 0x10

#define _D0_C 3 // little-endian, small long doubles
#define _D1_C 2
#define _D2_C 1
#define _D3_C 0

#define _DBIAS 0x3fe
#define _DOFF 4

#define _F0_C 1 // little-endian
#define _F1_C 0

#define _FBIAS 0x7e
#define _FOFF 7
#define _FRND 1

#define _L0_C 3 // little-endian, 64-bit long doubles
#define _L1_C 2
#define _L2_C 1
#define _L3_C 0

#define _LBIAS 0x3fe
#define _LOFF 4

// IEEE 754 double properties
#define _DFRAC ((unsigned short)((1 << _DOFF) - 1))
#define _DMASK ((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX ((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN ((unsigned short)0x8000)

// IEEE 754 float properties
#define _FFRAC ((unsigned short)((1 << _FOFF) - 1))
#define _FMASK ((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX ((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN ((unsigned short)0x8000)

// IEEE 754 long double properties
#define _LFRAC ((unsigned short)(-1))
#define _LMASK ((unsigned short)0x7fff)
#define _LMAX ((unsigned short)0x7fff)
#define _LSIGN ((unsigned short)0x8000)

#define _DHUGE_EXP (int)(_DMAX * 900L / 1000)
#define _FHUGE_EXP (int)(_FMAX * 900L / 1000)
#define _LHUGE_EXP (int)(_LMAX * 900L / 1000)

#define _DSIGN_C(_Val) (((_double_val*)(char*)&(_Val))->_Sh[_D0_C] & _DSIGN)
#define _FSIGN_C(_Val) (((_float_val*)(char*)&(_Val))->_Sh[_F0_C] & _FSIGN)
#define _LSIGN_C(_Val) (((_ldouble_val*)(char*)&(_Val))->_Sh[_L0_C] & _LSIGN)

void __cdecl _fperrraise(_In_ int _Except);

_Check_return_ _ACRTIMP short __cdecl _dclass(_In_ double _X);
_Check_return_ _ACRTIMP short __cdecl _ldclass(_In_ long double _X);
_Check_return_ _ACRTIMP short __cdecl _fdclass(_In_ float _X);

_Check_return_ _ACRTIMP int __cdecl _dsign(_In_ double _X);
_Check_return_ _ACRTIMP int __cdecl _ldsign(_In_ long double _X);
_Check_return_ _ACRTIMP int __cdecl _fdsign(_In_ float _X);

_Check_return_ _ACRTIMP int __cdecl _dpcomp(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP int __cdecl _ldpcomp(_In_ long double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP int __cdecl _fdpcomp(_In_ float _X, _In_ float _Y);

_Check_return_ _ACRTIMP short __cdecl _dtest(_In_ double* _Px);
_Check_return_ _ACRTIMP short __cdecl _ldtest(_In_ long double* _Px);
_Check_return_ _ACRTIMP short __cdecl _fdtest(_In_ float* _Px);

_ACRTIMP short __cdecl _d_int(_Inout_ double* _Px, _In_ short _Xexp);
_ACRTIMP short __cdecl _ld_int(_Inout_ long double* _Px, _In_ short _Xexp);
_ACRTIMP short __cdecl _fd_int(_Inout_ float* _Px, _In_ short _Xexp);

_ACRTIMP short __cdecl _dscale(_Inout_ double* _Px, _In_ long _Lexp);
_ACRTIMP short __cdecl _ldscale(_Inout_ long double* _Px, _In_ long _Lexp);
_ACRTIMP short __cdecl _fdscale(_Inout_ float* _Px, _In_ long _Lexp);

_ACRTIMP short __cdecl _dunscale(_Out_ short* _Pex, _Inout_ double* _Px);
_ACRTIMP short __cdecl _ldunscale(_Out_ short* _Pex, _Inout_ long double* _Px);
_ACRTIMP short __cdecl _fdunscale(_Out_ short* _Pex, _Inout_ float* _Px);

_Check_return_ _ACRTIMP short __cdecl _dexp(_Inout_ double* _Px, _In_ double _Y, _In_ long _Eoff);
_Check_return_ _ACRTIMP short __cdecl _ldexp(_Inout_ long double* _Px, _In_ long double _Y, _In_ long _Eoff);
_Check_return_ _ACRTIMP short __cdecl _fdexp(_Inout_ float* _Px, _In_ float _Y, _In_ long _Eoff);

_Check_return_ _ACRTIMP short __cdecl _dnorm(_Inout_updates_(4) unsigned short* _Ps);
_Check_return_ _ACRTIMP short __cdecl _fdnorm(_Inout_updates_(2) unsigned short* _Ps);

_Check_return_ _ACRTIMP double __cdecl _dpoly(_In_ double _X, _In_reads_(_N) double const* _Tab, _In_ int _N);
_Check_return_ _ACRTIMP long double __cdecl _ldpoly(_In_ long double _X, _In_reads_(_N) long double const* _Tab,
                                                    _In_ int _N);
_Check_return_ _ACRTIMP float __cdecl _fdpoly(_In_ float _X, _In_reads_(_N) float const* _Tab, _In_ int _N);

_Check_return_ _ACRTIMP double __cdecl _dlog(_In_ double _X, _In_ int _Baseflag);
_Check_return_ _ACRTIMP long double __cdecl _ldlog(_In_ long double _X, _In_ int _Baseflag);
_Check_return_ _ACRTIMP float __cdecl _fdlog(_In_ float _X, _In_ int _Baseflag);

_Check_return_ _ACRTIMP double __cdecl _dsin(_In_ double _X, _In_ unsigned int _Qoff);
_Check_return_ _ACRTIMP long double __cdecl _ldsin(_In_ long double _X, _In_ unsigned int _Qoff);
_Check_return_ _ACRTIMP float __cdecl _fdsin(_In_ float _X, _In_ unsigned int _Qoff);

// double declarations
typedef union { // pun floating type as integer array
  unsigned short _Sh[4];
  double _Val;
} _double_val;

// float declarations
typedef union { // pun floating type as integer array
  unsigned short _Sh[2];
  float _Val;
} _float_val;

// long double declarations
typedef union { // pun floating type as integer array
  unsigned short _Sh[4];
  long double _Val;
} _ldouble_val;

typedef union { // pun float types as integer array
  unsigned short _Word[4];
  float _Float;
  double _Double;
  long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C, _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double _Zero_C, _Xbig_C;
extern const float _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;

#define _FP_LT 1
#define _FP_EQ 2
#define _FP_GT 4

#ifndef __cplusplus

#define _CLASS_ARG(_Val)                                                                   \
  __pragma(warning(suppress : 6334))(sizeof((_Val) + (float)0) == sizeof(float)     ? 'f'  \
                                     : sizeof((_Val) + (double)0) == sizeof(double) ? 'd'  \
                                                                                    : 'l')
#define _CLASSIFY(_Val, _FFunc, _DFunc, _LDFunc)             \
  (_CLASS_ARG(_Val) == 'f'   ? _FFunc((float)(_Val))         \
   : _CLASS_ARG(_Val) == 'd' ? _DFunc((double)(_Val))        \
                             : _LDFunc((long double)(_Val)))
#define _CLASSIFY2(_Val1, _Val2, _FFunc, _DFunc, _LDFunc)                                        \
  (_CLASS_ARG((_Val1) + (_Val2)) == 'f'   ? _FFunc((float)(_Val1), (float)(_Val2))               \
   : _CLASS_ARG((_Val1) + (_Val2)) == 'd' ? _DFunc((double)(_Val1), (double)(_Val2))             \
                                          : _LDFunc((long double)(_Val1), (long double)(_Val2)))

#define fpclassify(_Val) (_CLASSIFY(_Val, _fdclass, _dclass, _ldclass))
#define _FPCOMPARE(_Val1, _Val2) (_CLASSIFY2(_Val1, _Val2, _fdpcomp, _dpcomp, _ldpcomp))

#define isfinite(_Val) (fpclassify(_Val) <= 0)
#define isinf(_Val) (fpclassify(_Val) == FP_INFINITE)
#define isnan(_Val) (fpclassify(_Val) == FP_NAN)
#define isnormal(_Val) (fpclassify(_Val) == FP_NORMAL)
#define signbit(_Val) (_CLASSIFY(_Val, _fdsign, _dsign, _ldsign))

#define isgreater(x, y) ((_FPCOMPARE(x, y) & _FP_GT) != 0)
#define isgreaterequal(x, y) ((_FPCOMPARE(x, y) & (_FP_EQ | _FP_GT)) != 0)
#define isless(x, y) ((_FPCOMPARE(x, y) & _FP_LT) != 0)
#define islessequal(x, y) ((_FPCOMPARE(x, y) & (_FP_LT | _FP_EQ)) != 0)
#define islessgreater(x, y) ((_FPCOMPARE(x, y) & (_FP_LT | _FP_GT)) != 0)
#define isunordered(x, y) (_FPCOMPARE(x, y) == 0)

#else  // __cplusplus
extern "C++" {
_Check_return_ inline int fpclassify(_In_ float _X) throw() { return _fdtest(&_X); }

_Check_return_ inline int fpclassify(_In_ double _X) throw() { return _dtest(&_X); }

_Check_return_ inline int fpclassify(_In_ long double _X) throw() { return _ldtest(&_X); }

_Check_return_ inline bool signbit(_In_ float _X) throw() { return _fdsign(_X) != 0; }

_Check_return_ inline bool signbit(_In_ double _X) throw() { return _dsign(_X) != 0; }

_Check_return_ inline bool signbit(_In_ long double _X) throw() { return _ldsign(_X) != 0; }

_Check_return_ inline int _fpcomp(_In_ float _X, _In_ float _Y) throw() { return _fdpcomp(_X, _Y); }

_Check_return_ inline int _fpcomp(_In_ double _X, _In_ double _Y) throw() { return _dpcomp(_X, _Y); }

_Check_return_ inline int _fpcomp(_In_ long double _X, _In_ long double _Y) throw() { return _ldpcomp(_X, _Y); }

template<class _Trc, class _Tre> struct _Combined_type { // determine combined type
  typedef float _Type;
};

template<> struct _Combined_type<float, double> { // determine combined type
  typedef double _Type;
};

template<> struct _Combined_type<float, long double> { // determine combined type
  typedef long double _Type;
};

template<class _Ty, class _T2> struct _Real_widened { // determine widened real type
  typedef long double _Type;
};

template<> struct _Real_widened<float, float> { // determine widened real type
  typedef float _Type;
};

template<> struct _Real_widened<float, double> { // determine widened real type
  typedef double _Type;
};

template<> struct _Real_widened<double, float> { // determine widened real type
  typedef double _Type;
};

template<> struct _Real_widened<double, double> { // determine widened real type
  typedef double _Type;
};

template<class _Ty> struct _Real_type { // determine equivalent real type
  typedef double _Type;                 // default is double
};

template<> struct _Real_type<float> { // determine equivalent real type
  typedef float _Type;
};

template<> struct _Real_type<long double> { // determine equivalent real type
  typedef long double _Type;
};

template<class _T1, class _T2>
_Check_return_ inline int _fpcomp(_In_ _T1 _X, _In_ _T2 _Y) throw() { // compare _Left and _Right
  typedef typename _Combined_type<
    float, typename _Real_widened<typename _Real_type<_T1>::_Type, typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
  return _fpcomp((_Tw)_X, (_Tw)_Y);
}

template<class _Ty> _Check_return_ inline bool isfinite(_In_ _Ty _X) throw() { return fpclassify(_X) <= 0; }

template<class _Ty> _Check_return_ inline bool isinf(_In_ _Ty _X) throw() { return fpclassify(_X) == FP_INFINITE; }

template<class _Ty> _Check_return_ inline bool isnan(_In_ _Ty _X) throw() { return fpclassify(_X) == FP_NAN; }

template<class _Ty> _Check_return_ inline bool isnormal(_In_ _Ty _X) throw() { return fpclassify(_X) == FP_NORMAL; }

template<class _Ty1, class _Ty2> _Check_return_ inline bool isgreater(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw() {
  return (_fpcomp(_X, _Y) & _FP_GT) != 0;
}

template<class _Ty1, class _Ty2> _Check_return_ inline bool isgreaterequal(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw() {
  return (_fpcomp(_X, _Y) & (_FP_EQ | _FP_GT)) != 0;
}

template<class _Ty1, class _Ty2> _Check_return_ inline bool isless(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw() {
  return (_fpcomp(_X, _Y) & _FP_LT) != 0;
}

template<class _Ty1, class _Ty2> _Check_return_ inline bool islessequal(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw() {
  return (_fpcomp(_X, _Y) & (_FP_LT | _FP_EQ)) != 0;
}

template<class _Ty1, class _Ty2> _Check_return_ inline bool islessgreater(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw() {
  return (_fpcomp(_X, _Y) & (_FP_LT | _FP_GT)) != 0;
}

template<class _Ty1, class _Ty2> _Check_return_ inline bool isunordered(_In_ _Ty1 _X, _In_ _Ty2 _Y) throw() {
  return _fpcomp(_X, _Y) == 0;
}
} // extern "C++"
#endif // __cplusplus

#if _CRT_FUNCTIONS_REQUIRED

_Check_return_ int __cdecl abs(_In_ int _X);
_Check_return_ long __cdecl labs(_In_ long _X);
_Check_return_ long long __cdecl llabs(_In_ long long _X);

_Check_return_ double __cdecl acos(_In_ double _X);
_Check_return_ double __cdecl asin(_In_ double _X);
_Check_return_ double __cdecl atan(_In_ double _X);
_Check_return_ double __cdecl atan2(_In_ double _Y, _In_ double _X);

_Check_return_ double __cdecl cos(_In_ double _X);
_Check_return_ double __cdecl cosh(_In_ double _X);
_Check_return_ double __cdecl exp(_In_ double _X);
_Check_return_ _CRT_JIT_INTRINSIC double __cdecl fabs(_In_ double _X);
_Check_return_ double __cdecl fmod(_In_ double _X, _In_ double _Y);
_Check_return_ double __cdecl log(_In_ double _X);
_Check_return_ double __cdecl log10(_In_ double _X);
_Check_return_ double __cdecl pow(_In_ double _X, _In_ double _Y);
_Check_return_ double __cdecl sin(_In_ double _X);
_Check_return_ double __cdecl sinh(_In_ double _X);
_Check_return_ _CRT_JIT_INTRINSIC double __cdecl sqrt(_In_ double _X);
_Check_return_ double __cdecl tan(_In_ double _X);
_Check_return_ double __cdecl tanh(_In_ double _X);

_Check_return_ _ACRTIMP double __cdecl acosh(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl asinh(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl atanh(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl atof(_In_z_ char const* _String);
_Check_return_ _ACRTIMP double __cdecl _atof_l(_In_z_ char const* _String, _In_opt_ _locale_t _Locale);
_Check_return_ _ACRTIMP double __cdecl _cabs(_In_ struct _complex _Complex_value);
_Check_return_ _ACRTIMP double __cdecl cbrt(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl ceil(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _chgsign(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl copysign(_In_ double _Number, _In_ double _Sign);
_Check_return_ _ACRTIMP double __cdecl _copysign(_In_ double _Number, _In_ double _Sign);
_Check_return_ _ACRTIMP double __cdecl erf(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl erfc(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl exp2(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl expm1(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl fdim(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl floor(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl fma(_In_ double _X, _In_ double _Y, _In_ double _Z);
_Check_return_ _ACRTIMP double __cdecl fmax(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl fmin(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl frexp(_In_ double _X, _Out_ int* _Y);
_Check_return_ _ACRTIMP double __cdecl hypot(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl _hypot(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP int __cdecl ilogb(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl ldexp(_In_ double _X, _In_ int _Y);
_Check_return_ _ACRTIMP double __cdecl lgamma(_In_ double _X);
_Check_return_ _ACRTIMP long long __cdecl llrint(_In_ double _X);
_Check_return_ _ACRTIMP long long __cdecl llround(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl log1p(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl log2(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl logb(_In_ double _X);
_Check_return_ _ACRTIMP long __cdecl lrint(_In_ double _X);
_Check_return_ _ACRTIMP long __cdecl lround(_In_ double _X);

int __CRTDECL _matherr(_Inout_ struct _exception* _Except);

_Check_return_ _ACRTIMP double __cdecl modf(_In_ double _X, _Out_ double* _Y);
_Check_return_ _ACRTIMP double __cdecl nan(_In_ char const* _X);
_Check_return_ _ACRTIMP double __cdecl nearbyint(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl nextafter(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl nexttoward(_In_ double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP double __cdecl remainder(_In_ double _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl remquo(_In_ double _X, _In_ double _Y, _Out_ int* _Z);
_Check_return_ _ACRTIMP double __cdecl rint(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl round(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl scalbln(_In_ double _X, _In_ long _Y);
_Check_return_ _ACRTIMP double __cdecl scalbn(_In_ double _X, _In_ int _Y);
_Check_return_ _ACRTIMP double __cdecl tgamma(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl trunc(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _j0(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _j1(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _jn(int _X, _In_ double _Y);
_Check_return_ _ACRTIMP double __cdecl _y0(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _y1(_In_ double _X);
_Check_return_ _ACRTIMP double __cdecl _yn(_In_ int _X, _In_ double _Y);

_Check_return_ _ACRTIMP float __cdecl acoshf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl asinhf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl atanhf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl cbrtf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl _chgsignf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl copysignf(_In_ float _Number, _In_ float _Sign);
_Check_return_ _ACRTIMP float __cdecl _copysignf(_In_ float _Number, _In_ float _Sign);
_Check_return_ _ACRTIMP float __cdecl erff(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl erfcf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl expm1f(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl exp2f(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl fdimf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float __cdecl fmaf(_In_ float _X, _In_ float _Y, _In_ float _Z);
_Check_return_ _ACRTIMP float __cdecl fmaxf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float __cdecl fminf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float __cdecl _hypotf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP int __cdecl ilogbf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl lgammaf(_In_ float _X);
_Check_return_ _ACRTIMP long long __cdecl llrintf(_In_ float _X);
_Check_return_ _ACRTIMP long long __cdecl llroundf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl log1pf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl log2f(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl logbf(_In_ float _X);
_Check_return_ _ACRTIMP long __cdecl lrintf(_In_ float _X);
_Check_return_ _ACRTIMP long __cdecl lroundf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl nanf(_In_ char const* _X);
_Check_return_ _ACRTIMP float __cdecl nearbyintf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl nextafterf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float __cdecl nexttowardf(_In_ float _X, _In_ long double _Y);
_Check_return_ _ACRTIMP float __cdecl remainderf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float __cdecl remquof(_In_ float _X, _In_ float _Y, _Out_ int* _Z);
_Check_return_ _ACRTIMP float __cdecl rintf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl roundf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl scalblnf(_In_ float _X, _In_ long _Y);
_Check_return_ _ACRTIMP float __cdecl scalbnf(_In_ float _X, _In_ int _Y);
_Check_return_ _ACRTIMP float __cdecl tgammaf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl truncf(_In_ float _X);

#if defined _M_IX86

_Check_return_ _ACRTIMP int __cdecl _set_SSE2_enable(_In_ int _Flag);

#endif

#if defined _M_X64

_Check_return_ _ACRTIMP float __cdecl _logbf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl _nextafterf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP int __cdecl _finitef(_In_ float _X);
_Check_return_ _ACRTIMP int __cdecl _isnanf(_In_ float _X);
_Check_return_ _ACRTIMP int __cdecl _fpclassf(_In_ float _X);

_Check_return_ _ACRTIMP int __cdecl _set_FMA3_enable(_In_ int _Flag);
_Check_return_ _ACRTIMP int __cdecl _get_FMA3_enable(void);

#elif defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64

_Check_return_ _ACRTIMP int __cdecl _finitef(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl _logbf(_In_ float _X);

#endif

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || \
  defined _CORECRT_BUILD_APISET || defined _M_ARM64EC

_Check_return_ _ACRTIMP float __cdecl acosf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl asinf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl atan2f(_In_ float _Y, _In_ float _X);
_Check_return_ _ACRTIMP float __cdecl atanf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl ceilf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl cosf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl coshf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl expf(_In_ float _X);

#else

_Check_return_ __inline float __CRTDECL acosf(_In_ float _X) { return (float)acos(_X); }

_Check_return_ __inline float __CRTDECL asinf(_In_ float _X) { return (float)asin(_X); }

_Check_return_ __inline float __CRTDECL atan2f(_In_ float _Y, _In_ float _X) { return (float)atan2(_Y, _X); }

_Check_return_ __inline float __CRTDECL atanf(_In_ float _X) { return (float)atan(_X); }

_Check_return_ __inline float __CRTDECL ceilf(_In_ float _X) { return (float)ceil(_X); }

_Check_return_ __inline float __CRTDECL cosf(_In_ float _X) { return (float)cos(_X); }

_Check_return_ __inline float __CRTDECL coshf(_In_ float _X) { return (float)cosh(_X); }

_Check_return_ __inline float __CRTDECL expf(_In_ float _X) { return (float)exp(_X); }

#endif

#if defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _M_ARM64EC

_Check_return_ _CRT_JIT_INTRINSIC _ACRTIMP float __cdecl fabsf(_In_ float _X);

#if defined _M_ARM64EC
#pragma intrinsic(fabsf)
#endif

#else

_Check_return_ __inline float __CRTDECL fabsf(_In_ float _X) { return (float)fabs(_X); }

#endif

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || defined _M_ARM64EC

_Check_return_ _ACRTIMP float __cdecl floorf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl fmodf(_In_ float _X, _In_ float _Y);

#else

_Check_return_ __inline float __CRTDECL floorf(_In_ float _X) { return (float)floor(_X); }

_Check_return_ __inline float __CRTDECL fmodf(_In_ float _X, _In_ float _Y) { return (float)fmod(_X, _Y); }

#endif

_Check_return_ __inline float __CRTDECL frexpf(_In_ float _X, _Out_ int* _Y) { return (float)frexp(_X, _Y); }

_Check_return_ __inline float __CRTDECL hypotf(_In_ float _X, _In_ float _Y) { return _hypotf(_X, _Y); }

_Check_return_ __inline float __CRTDECL ldexpf(_In_ float _X, _In_ int _Y) { return (float)ldexp(_X, _Y); }

#if defined _M_X64 || defined _M_ARM || defined _M_ARM64 || defined _M_HYBRID_X86_ARM64 || \
  defined _CORECRT_BUILD_APISET || defined _M_ARM64EC

_Check_return_ _ACRTIMP float __cdecl log10f(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl logf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl modff(_In_ float _X, _Out_ float* _Y);
_Check_return_ _ACRTIMP float __cdecl powf(_In_ float _X, _In_ float _Y);
_Check_return_ _ACRTIMP float __cdecl sinf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl sinhf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl sqrtf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl tanf(_In_ float _X);
_Check_return_ _ACRTIMP float __cdecl tanhf(_In_ float _X);

#else

_Check_return_ __inline float __CRTDECL log10f(_In_ float _X) { return (float)log10(_X); }

_Check_return_ __inline float __CRTDECL logf(_In_ float _X) { return (float)log(_X); }

_Check_return_ __inline float __CRTDECL modff(_In_ float _X, _Out_ float* _Y) {
  double _F, _I;
  _F = modf(_X, &_I);
  *_Y = (float)_I;
  return (float)_F;
}

_Check_return_ __inline float __CRTDECL powf(_In_ float _X, _In_ float _Y) { return (float)pow(_X, _Y); }

_Check_return_ __inline float __CRTDECL sinf(_In_ float _X) { return (float)sin(_X); }

_Check_return_ __inline float __CRTDECL sinhf(_In_ float _X) { return (float)sinh(_X); }

_Check_return_ __inline float __CRTDECL sqrtf(_In_ float _X) { return (float)sqrt(_X); }

_Check_return_ __inline float __CRTDECL tanf(_In_ float _X) { return (float)tan(_X); }

_Check_return_ __inline float __CRTDECL tanhf(_In_ float _X) { return (float)tanh(_X); }

#endif

_Check_return_ _ACRTIMP long double __cdecl acoshl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL acosl(_In_ long double _X) { return acos((double)_X); }

_Check_return_ _ACRTIMP long double __cdecl asinhl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL asinl(_In_ long double _X) { return asin((double)_X); }

_Check_return_ __inline long double __CRTDECL atan2l(_In_ long double _Y, _In_ long double _X) {
  return atan2((double)_Y, (double)_X);
}

_Check_return_ _ACRTIMP long double __cdecl atanhl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL atanl(_In_ long double _X) { return atan((double)_X); }

_Check_return_ _ACRTIMP long double __cdecl cbrtl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL ceill(_In_ long double _X) { return ceil((double)_X); }

_Check_return_ __inline long double __CRTDECL _chgsignl(_In_ long double _X) { return _chgsign((double)_X); }

_Check_return_ _ACRTIMP long double __cdecl copysignl(_In_ long double _Number, _In_ long double _Sign);

_Check_return_ __inline long double __CRTDECL _copysignl(_In_ long double _Number, _In_ long double _Sign) {
  return _copysign((double)_Number, (double)_Sign);
}

_Check_return_ __inline long double __CRTDECL coshl(_In_ long double _X) { return cosh((double)_X); }

_Check_return_ __inline long double __CRTDECL cosl(_In_ long double _X) { return cos((double)_X); }

_Check_return_ _ACRTIMP long double __cdecl erfl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl erfcl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL expl(_In_ long double _X) { return exp((double)_X); }

_Check_return_ _ACRTIMP long double __cdecl exp2l(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl expm1l(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL fabsl(_In_ long double _X) { return fabs((double)_X); }

_Check_return_ _ACRTIMP long double __cdecl fdiml(_In_ long double _X, _In_ long double _Y);

_Check_return_ __inline long double __CRTDECL floorl(_In_ long double _X) { return floor((double)_X); }

_Check_return_ _ACRTIMP long double __cdecl fmal(_In_ long double _X, _In_ long double _Y, _In_ long double _Z);
_Check_return_ _ACRTIMP long double __cdecl fmaxl(_In_ long double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP long double __cdecl fminl(_In_ long double _X, _In_ long double _Y);

_Check_return_ __inline long double __CRTDECL fmodl(_In_ long double _X, _In_ long double _Y) {
  return fmod((double)_X, (double)_Y);
}

_Check_return_ __inline long double __CRTDECL frexpl(_In_ long double _X, _Out_ int* _Y) {
  return frexp((double)_X, _Y);
}

_Check_return_ _ACRTIMP int __cdecl ilogbl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL _hypotl(_In_ long double _X, _In_ long double _Y) {
  return _hypot((double)_X, (double)_Y);
}

_Check_return_ __inline long double __CRTDECL hypotl(_In_ long double _X, _In_ long double _Y) {
  return _hypot((double)_X, (double)_Y);
}

_Check_return_ __inline long double __CRTDECL ldexpl(_In_ long double _X, _In_ int _Y) { return ldexp((double)_X, _Y); }

_Check_return_ _ACRTIMP long double __cdecl lgammal(_In_ long double _X);
_Check_return_ _ACRTIMP long long __cdecl llrintl(_In_ long double _X);
_Check_return_ _ACRTIMP long long __cdecl llroundl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL logl(_In_ long double _X) { return log((double)_X); }

_Check_return_ __inline long double __CRTDECL log10l(_In_ long double _X) { return log10((double)_X); }

_Check_return_ _ACRTIMP long double __cdecl log1pl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl log2l(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl logbl(_In_ long double _X);
_Check_return_ _ACRTIMP long __cdecl lrintl(_In_ long double _X);
_Check_return_ _ACRTIMP long __cdecl lroundl(_In_ long double _X);

_Check_return_ __inline long double __CRTDECL modfl(_In_ long double _X, _Out_ long double* _Y) {
  double _F, _I;
  _F = modf((double)_X, &_I);
  *_Y = _I;
  return _F;
}

_Check_return_ _ACRTIMP long double __cdecl nanl(_In_ char const* _X);
_Check_return_ _ACRTIMP long double __cdecl nearbyintl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl nextafterl(_In_ long double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP long double __cdecl nexttowardl(_In_ long double _X, _In_ long double _Y);

_Check_return_ __inline long double __CRTDECL powl(_In_ long double _X, _In_ long double _Y) {
  return pow((double)_X, (double)_Y);
}

_Check_return_ _ACRTIMP long double __cdecl remainderl(_In_ long double _X, _In_ long double _Y);
_Check_return_ _ACRTIMP long double __cdecl remquol(_In_ long double _X, _In_ long double _Y, _Out_ int* _Z);
_Check_return_ _ACRTIMP long double __cdecl rintl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl roundl(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl scalblnl(_In_ long double _X, _In_ long _Y);
_Check_return_ _ACRTIMP long double __cdecl scalbnl(_In_ long double _X, _In_ int _Y);

_Check_return_ __inline long double __CRTDECL sinhl(_In_ long double _X) { return sinh((double)_X); }

_Check_return_ __inline long double __CRTDECL sinl(_In_ long double _X) { return sin((double)_X); }

_Check_return_ __inline long double __CRTDECL sqrtl(_In_ long double _X) { return sqrt((double)_X); }

_Check_return_ __inline long double __CRTDECL tanhl(_In_ long double _X) { return tanh((double)_X); }

_Check_return_ __inline long double __CRTDECL tanl(_In_ long double _X) { return tan((double)_X); }

_Check_return_ _ACRTIMP long double __cdecl tgammal(_In_ long double _X);
_Check_return_ _ACRTIMP long double __cdecl truncl(_In_ long double _X);

#ifndef __cplusplus
#define _matherrl _matherr
#endif

#endif // _CRT_FUNCTIONS_REQUIRED

#if defined(_CRT_INTERNAL_NONSTDC_NAMES) && _CRT_INTERNAL_NONSTDC_NAMES

#define DOMAIN _DOMAIN
#define SING _SING
#define OVERFLOW _OVERFLOW
#define UNDERFLOW _UNDERFLOW
#define TLOSS _TLOSS
#define PLOSS _PLOSS

#define matherr _matherr

#ifndef __assembler
#ifndef _M_CEE_PURE
extern double HUGE;
#else
double const HUGE = _HUGE;
#endif

_CRT_NONSTDC_DEPRECATE(_j0) _Check_return_ _ACRTIMP double __cdecl j0(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_j1) _Check_return_ _ACRTIMP double __cdecl j1(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_jn) _Check_return_ _ACRTIMP double __cdecl jn(_In_ int _X, _In_ double _Y);
_CRT_NONSTDC_DEPRECATE(_y0) _Check_return_ _ACRTIMP double __cdecl y0(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_y1) _Check_return_ _ACRTIMP double __cdecl y1(_In_ double _X);
_CRT_NONSTDC_DEPRECATE(_yn) _Check_return_ _ACRTIMP double __cdecl yn(_In_ int _X, _In_ double _Y);
#endif // !__assembler

#endif // _CRT_INTERNAL_NONSTDC_NAMES

_CRT_END_C_HEADER

_EXTERN_CXX_WORKAROUND
_NODISCARD _Check_return_ inline float acos(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD acosf(_Xx); }

_NODISCARD _Check_return_ inline float acosh(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD acoshf(_Xx); }

_NODISCARD _Check_return_ inline float asin(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD asinf(_Xx); }

_NODISCARD _Check_return_ inline float asinh(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD asinhf(_Xx); }

_NODISCARD _Check_return_ inline float atan(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD atanf(_Xx); }

_NODISCARD _Check_return_ inline float atanh(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD atanhf(_Xx); }

_NODISCARD _Check_return_ inline float atan2(_In_ float _Yx, _In_ float _Xx) noexcept /* strengthened */ {
  return _CSTD atan2f(_Yx, _Xx);
}

_NODISCARD _Check_return_ inline float cbrt(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD cbrtf(_Xx); }

_NODISCARD _Check_return_ inline float ceil(_In_ float _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __ceilf(_Xx);
#elif defined(__clang__)
  return __builtin_ceilf(_Xx);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD ceilf(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline float copysign(_In_ float _Number, _In_ float _Sign) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __copysignf(_Number, _Sign);
#elif defined(__clang__)
  return __builtin_copysignf(_Number, _Sign);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD copysignf(_Number, _Sign);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline float cos(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD cosf(_Xx); }

_NODISCARD _Check_return_ inline float cosh(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD coshf(_Xx); }

_NODISCARD _Check_return_ inline float erf(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD erff(_Xx); }

_NODISCARD _Check_return_ inline float erfc(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD erfcf(_Xx); }

_NODISCARD _Check_return_ inline float exp(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD expf(_Xx); }

_NODISCARD _Check_return_ inline float exp2(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD exp2f(_Xx); }

_NODISCARD _Check_return_ inline float expm1(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD expm1f(_Xx); }

_NODISCARD _Check_return_ inline float fabs(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD fabsf(_Xx); }

_NODISCARD _Check_return_ inline float fdim(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
  return _CSTD fdimf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float floor(_In_ float _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __floorf(_Xx);
#elif defined(__clang__)
  return __builtin_floorf(_Xx);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD floorf(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline float fma(_In_ float _Xx, _In_ float _Yx, _In_ float _Zx) noexcept /* strengthened */ {
  return _CSTD fmaf(_Xx, _Yx, _Zx);
}

_NODISCARD _Check_return_ inline float fmax(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
  return _CSTD fmaxf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float fmin(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
  return _CSTD fminf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float fmod(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
  return _CSTD fmodf(_Xx, _Yx);
}

inline float frexp(_In_ float _Xx, _Out_ int* _Yx) noexcept /* strengthened */ { return _CSTD frexpf(_Xx, _Yx); }

_NODISCARD _Check_return_ inline float hypot(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
  return _CSTD hypotf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline int ilogb(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD ilogbf(_Xx); }

_NODISCARD _Check_return_ inline float ldexp(_In_ float _Xx, _In_ int _Yx) noexcept /* strengthened */ {
  return _CSTD ldexpf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float lgamma(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD lgammaf(_Xx); }

_NODISCARD _Check_return_ inline long long llrint(_In_ float _Xx) noexcept /* strengthened */ {
  return _CSTD llrintf(_Xx);
}

_NODISCARD _Check_return_ inline long long llround(_In_ float _Xx) noexcept /* strengthened */ {
  return _CSTD llroundf(_Xx);
}

_NODISCARD _Check_return_ inline float log(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD logf(_Xx); }

_NODISCARD _Check_return_ inline float log10(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD log10f(_Xx); }

_NODISCARD _Check_return_ inline float log1p(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD log1pf(_Xx); }

_NODISCARD _Check_return_ inline float log2(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD log2f(_Xx); }

_NODISCARD _Check_return_ inline float logb(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD logbf(_Xx); }

_NODISCARD _Check_return_ inline long lrint(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD lrintf(_Xx); }

_NODISCARD _Check_return_ inline long lround(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD lroundf(_Xx); }

inline float modf(_In_ float _Xx, _Out_ float* _Yx) noexcept /* strengthened */ { return _CSTD modff(_Xx, _Yx); }

_NODISCARD _Check_return_ inline float nearbyint(_In_ float _Xx) noexcept /* strengthened */ {
  return _CSTD nearbyintf(_Xx);
}

_NODISCARD _Check_return_ inline float nextafter(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
  return _CSTD nextafterf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float nexttoward(_In_ float _Xx, _In_ long double _Yx) noexcept /* strengthened */ {
  return _CSTD nexttowardf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float pow(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
  return _CSTD powf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float remainder(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {
  return _CSTD remainderf(_Xx, _Yx);
}

inline float remquo(_In_ float _Xx, _In_ float _Yx, _Out_ int* _Zx) noexcept /* strengthened */ {
  return _CSTD remquof(_Xx, _Yx, _Zx);
}

_NODISCARD _Check_return_ inline float rint(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD rintf(_Xx); }

_NODISCARD _Check_return_ inline float round(_In_ float _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __roundf(_Xx);
#elif defined(__clang__)
  return __builtin_roundf(_Xx);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD roundf(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline float scalbln(_In_ float _Xx, _In_ long _Yx) noexcept /* strengthened */ {
  return _CSTD scalblnf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float scalbn(_In_ float _Xx, _In_ int _Yx) noexcept /* strengthened */ {
  return _CSTD scalbnf(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline float sin(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD sinf(_Xx); }

_NODISCARD _Check_return_ inline float sinh(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD sinhf(_Xx); }

_NODISCARD _Check_return_ inline float sqrt(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD sqrtf(_Xx); }

_NODISCARD _Check_return_ inline float tan(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD tanf(_Xx); }

_NODISCARD _Check_return_ inline float tanh(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD tanhf(_Xx); }

_NODISCARD _Check_return_ inline float tgamma(_In_ float _Xx) noexcept /* strengthened */ { return _CSTD tgammaf(_Xx); }

_NODISCARD _Check_return_ inline float trunc(_In_ float _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __truncf(_Xx);
#elif defined(__clang__)
  return __builtin_truncf(_Xx);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD truncf(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double acos(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD acosl(_Xx);
}

_NODISCARD _Check_return_ inline long double acosh(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD acoshl(_Xx);
}

_NODISCARD _Check_return_ inline long double asin(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD asinl(_Xx);
}

_NODISCARD _Check_return_ inline long double asinh(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD asinhl(_Xx);
}

_NODISCARD _Check_return_ inline long double atan(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD atanl(_Xx);
}

_NODISCARD _Check_return_ inline long double atanh(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD atanhl(_Xx);
}

_NODISCARD _Check_return_ inline long double atan2(_In_ long double _Yx, _In_ long double _Xx) noexcept
/* strengthened */ {
  return _CSTD atan2l(_Yx, _Xx);
}

_NODISCARD _Check_return_ inline long double cbrt(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD cbrtl(_Xx);
}

_NODISCARD _Check_return_ inline long double ceil(_In_ long double _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __ceil(static_cast<double>(_Xx));
#elif defined(__clang__)
  return __builtin_ceill(_Xx);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD ceill(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double copysign(_In_ long double _Number, _In_ long double _Sign) noexcept
/* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __copysign(static_cast<double>(_Number), static_cast<double>(_Sign));
#elif defined(__clang__)
  return __builtin_copysignl(_Number, _Sign);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD copysignl(_Number, _Sign);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double cos(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD cosl(_Xx);
}

_NODISCARD _Check_return_ inline long double cosh(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD coshl(_Xx);
}

_NODISCARD _Check_return_ inline long double erf(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD erfl(_Xx);
}

_NODISCARD _Check_return_ inline long double erfc(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD erfcl(_Xx);
}

_NODISCARD _Check_return_ inline long double exp(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD expl(_Xx);
}

_NODISCARD _Check_return_ inline long double exp2(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD exp2l(_Xx);
}

_NODISCARD _Check_return_ inline long double expm1(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD expm1l(_Xx);
}

_NODISCARD _Check_return_ inline long double fabs(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD fabsl(_Xx);
}

_NODISCARD _Check_return_ inline long double fdim(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
  return _CSTD fdiml(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double floor(_In_ long double _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __floor(static_cast<double>(_Xx));
#elif defined(__clang__)
  return __builtin_floorl(_Xx);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD floorl(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double fma(_In_ long double _Xx, _In_ long double _Yx,
                                                 _In_ long double _Zx) noexcept /* strengthened */ {
  return _CSTD fmal(_Xx, _Yx, _Zx);
}

_NODISCARD _Check_return_ inline long double fmax(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
  return _CSTD fmaxl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double fmin(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
  return _CSTD fminl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double fmod(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
  return _CSTD fmodl(_Xx, _Yx);
}

inline long double frexp(_In_ long double _Xx, _Out_ int* _Yx) noexcept /* strengthened */ {
  return _CSTD frexpl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double hypot(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
  return _CSTD hypotl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline int ilogb(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD ilogbl(_Xx);
}

_NODISCARD _Check_return_ inline long double ldexp(_In_ long double _Xx, _In_ int _Yx) noexcept /* strengthened */ {
  return _CSTD ldexpl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double lgamma(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD lgammal(_Xx);
}

_NODISCARD _Check_return_ inline long long llrint(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD llrintl(_Xx);
}

_NODISCARD _Check_return_ inline long long llround(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD llroundl(_Xx);
}

_NODISCARD _Check_return_ inline long double log(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD logl(_Xx);
}

_NODISCARD _Check_return_ inline long double log10(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD log10l(_Xx);
}

_NODISCARD _Check_return_ inline long double log1p(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD log1pl(_Xx);
}

_NODISCARD _Check_return_ inline long double log2(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD log2l(_Xx);
}

_NODISCARD _Check_return_ inline long double logb(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD logbl(_Xx);
}

_NODISCARD _Check_return_ inline long lrint(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD lrintl(_Xx);
}

_NODISCARD _Check_return_ inline long lround(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD lroundl(_Xx);
}

inline long double modf(_In_ long double _Xx, _Out_ long double* _Yx) noexcept /* strengthened */ {
  return _CSTD modfl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double nearbyint(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD nearbyintl(_Xx);
}

_NODISCARD _Check_return_ inline long double nextafter(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
  return _CSTD nextafterl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double nexttoward(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
  return _CSTD nexttowardl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double pow(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
  return _CSTD powl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double remainder(_In_ long double _Xx, _In_ long double _Yx) noexcept
/* strengthened */ {
  return _CSTD remainderl(_Xx, _Yx);
}

inline long double remquo(_In_ long double _Xx, _In_ long double _Yx, _Out_ int* _Zx) noexcept /* strengthened */ {
  return _CSTD remquol(_Xx, _Yx, _Zx);
}

_NODISCARD _Check_return_ inline long double rint(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD rintl(_Xx);
}

_NODISCARD _Check_return_ inline long double round(_In_ long double _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __round(static_cast<double>(_Xx));
#elif defined(__clang__)
  return __builtin_roundl(_Xx);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD roundl(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}

_NODISCARD _Check_return_ inline long double scalbln(_In_ long double _Xx, _In_ long _Yx) noexcept /* strengthened */ {
  return _CSTD scalblnl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double scalbn(_In_ long double _Xx, _In_ int _Yx) noexcept /* strengthened */ {
  return _CSTD scalbnl(_Xx, _Yx);
}

_NODISCARD _Check_return_ inline long double sin(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD sinl(_Xx);
}

_NODISCARD _Check_return_ inline long double sinh(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD sinhl(_Xx);
}

_NODISCARD _Check_return_ inline long double sqrt(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD sqrtl(_Xx);
}

_NODISCARD _Check_return_ inline long double tan(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD tanl(_Xx);
}

_NODISCARD _Check_return_ inline long double tanh(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD tanhl(_Xx);
}

_NODISCARD _Check_return_ inline long double tgamma(_In_ long double _Xx) noexcept /* strengthened */ {
  return _CSTD tgammal(_Xx);
}

_NODISCARD _Check_return_ inline long double trunc(_In_ long double _Xx) noexcept /* strengthened */ {
#if _HAS_CMATH_INTRINSICS
  return __trunc(static_cast<double>(_Xx));
#elif defined(__clang__)
  return __builtin_truncl(_Xx);
#else  // ^^^ defined(__clang__) / intrinsics unavailable vvv
  return _CSTD truncl(_Xx);
#endif // ^^^ intrinsics unavailable ^^^
}
_END_EXTERN_CXX_WORKAROUND

_STD_BEGIN
template<class _Ty1, class _Ty2> using _Common_float_type_t =
  conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
                conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
                              double>>; // find type for two-argument math function
_STD_END

_EXTERN_CXX_WORKAROUND
template<class _Ty, _STD enable_if_t<_STD is_integral_v<_Ty>, int> = 0>
double frexp(_Ty _Value, _Out_ int* const _Exp) noexcept /* strengthened */ {
  return _CSTD frexp(static_cast<double>(_Value), _Exp);
}

template<
  class _Ty1, class _Ty2, class _Ty3,
  _STD enable_if_t<_STD is_arithmetic_v<_Ty1> && _STD is_arithmetic_v<_Ty2> && _STD is_arithmetic_v<_Ty3>, int> = 0>
_NODISCARD _STD _Common_float_type_t<_Ty1, _STD _Common_float_type_t<_Ty2, _Ty3>> fma(_Ty1 _Left, _Ty2 _Middle,
                                                                                      _Ty3 _Right) noexcept
/* strengthened */ {
  using _Common = _STD _Common_float_type_t<_Ty1, _STD _Common_float_type_t<_Ty2, _Ty3>>;
  if constexpr (_STD is_same_v<_Common, float>) {
    return _CSTD fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
  } else if constexpr (_STD is_same_v<_Common, double>) {
    return _CSTD fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
  } else {
    return _CSTD fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
  }
}

template<class _Ty1, class _Ty2, _STD enable_if_t<_STD is_arithmetic_v<_Ty1> && _STD is_arithmetic_v<_Ty2>, int> = 0>
_STD _Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept /* strengthened */ {
  using _Common = _STD _Common_float_type_t<_Ty1, _Ty2>;
  if constexpr (_STD is_same_v<_Common, float>) {
    return _CSTD remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
  } else if constexpr (_STD is_same_v<_Common, double>) {
    return _CSTD remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
  } else {
    return _CSTD remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
  }
}

#ifdef __clang__
// Clang provides efficient builtins; see GH-4609.
// TRANSITION, the UCRT's function templates should take advantage of these builtins.
// As a workaround, we can provide additional overloads that will be
// preferred by overload resolution when the types exactly match.

#define _CLANG_BUILTIN1_ARG(NAME, ARG)                                                         \
  _NODISCARD _Check_return_ _CONSTEXPR23 bool NAME(_In_ ARG _Xx) noexcept /* strengthened */ { \
    return __builtin_##NAME(_Xx);                                                              \
  }

// Updated by P0533R9 "constexpr For <cmath> And <cstdlib>".
// TRANSITION, Clang 20: The builtins were made constexpr by LLVM-94118.
#define _CLANG_BUILTIN2_ARG(NAME, ARG)                                                                 \
  _NODISCARD _Check_return_ inline bool NAME(_In_ ARG _Xx, _In_ ARG _Yx) noexcept /* strengthened */ { \
    return __builtin_##NAME(_Xx, _Yx);                                                                 \
  }

#define _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, ARG)                                                       \
  template<class _Ty, _STD enable_if_t<_STD is_arithmetic_v<_Ty>, int> = 0>                            \
  _NODISCARD _Check_return_ inline bool NAME(_In_ ARG _Xx, _In_ _Ty _Yx) noexcept /* strengthened */ { \
    return __builtin_##NAME(static_cast<double>(_Xx), static_cast<double>(_Yx));                       \
  }

#ifdef __cpp_char8_t
#define _CLANG_BUILTIN2_ARG_TEMPLATED_CHAR8_T(NAME)                                                        \
  template<class _Ty, _STD enable_if_t<_STD is_arithmetic_v<_Ty>, int> = 0>                                \
  _NODISCARD _Check_return_ inline bool NAME(_In_ char8_t _Xx, _In_ _Ty _Yx) noexcept /* strengthened */ { \
    return __builtin_##NAME(static_cast<double>(_Xx), static_cast<double>(_Yx));                           \
  }
#else // ^^^ defined(__cpp_char8_t) / !defined(__cpp_char8_t) vvv
#define _CLANG_BUILTIN2_ARG_TEMPLATED_CHAR8_T(NAME)
#endif // ^^^ !defined(__cpp_char8_t) ^^^

#ifdef _NATIVE_WCHAR_T_DEFINED
#define _CLANG_BUILTIN2_ARG_TEMPLATED_WCHAR_T(NAME)                                                        \
  template<class _Ty, _STD enable_if_t<_STD is_arithmetic_v<_Ty>, int> = 0>                                \
  _NODISCARD _Check_return_ inline bool NAME(_In_ wchar_t _Xx, _In_ _Ty _Yx) noexcept /* strengthened */ { \
    return __builtin_##NAME(static_cast<double>(_Xx), static_cast<double>(_Yx));                           \
  }
#else // ^^^ defined(_NATIVE_WCHAR_T_DEFINED) / !defined(_NATIVE_WCHAR_T_DEFINED) vvv
#define _CLANG_BUILTIN2_ARG_TEMPLATED_WCHAR_T(NAME)
#endif // ^^^ !defined(_NATIVE_WCHAR_T_DEFINED) ^^^

#define _CLANG_BUILTIN2_TEMPLATED(NAME)                   \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, float)              \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, double)             \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, long double)        \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, signed char)        \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, short)              \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, int)                \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, long)               \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, long long)          \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, unsigned char)      \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, unsigned short)     \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, unsigned int)       \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, unsigned long)      \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, unsigned long long) \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, bool)               \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, char)               \
  _CLANG_BUILTIN2_ARG_TEMPLATED_CHAR8_T(NAME)             \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, char16_t)           \
  _CLANG_BUILTIN2_ARG_TEMPLATED(NAME, char32_t)           \
  _CLANG_BUILTIN2_ARG_TEMPLATED_WCHAR_T(NAME)

#define _CLANG_BUILTIN1(NAME)            \
  _CLANG_BUILTIN1_ARG(NAME, float)       \
  _CLANG_BUILTIN1_ARG(NAME, double)      \
  _CLANG_BUILTIN1_ARG(NAME, long double)

#define _CLANG_BUILTIN2(NAME)            \
  _CLANG_BUILTIN2_ARG(NAME, float)       \
  _CLANG_BUILTIN2_ARG(NAME, double)      \
  _CLANG_BUILTIN2_ARG(NAME, long double)

_STL_DISABLE_CLANG_WARNING_NAN_INF_DISABLED
_CLANG_BUILTIN1(isfinite)
_CLANG_BUILTIN1(isinf)
_CLANG_BUILTIN1(isnan)
_STL_RESTORE_CLANG_WARNING_NAN_INF_DISABLED
_CLANG_BUILTIN1(isnormal)

_CLANG_BUILTIN2(isgreater)
_CLANG_BUILTIN2(isgreaterequal)
_CLANG_BUILTIN2(isless)
_CLANG_BUILTIN2(islessequal)
_CLANG_BUILTIN2(islessgreater)
_STL_DISABLE_CLANG_WARNING_NAN_INF_DISABLED
_CLANG_BUILTIN2(isunordered)
_STL_RESTORE_CLANG_WARNING_NAN_INF_DISABLED

_CLANG_BUILTIN2_TEMPLATED(isgreater)
_CLANG_BUILTIN2_TEMPLATED(isgreaterequal)
_CLANG_BUILTIN2_TEMPLATED(isless)
_CLANG_BUILTIN2_TEMPLATED(islessequal)
_CLANG_BUILTIN2_TEMPLATED(islessgreater)
_STL_DISABLE_CLANG_WARNING_NAN_INF_DISABLED
_CLANG_BUILTIN2_TEMPLATED(isunordered)
_STL_RESTORE_CLANG_WARNING_NAN_INF_DISABLED

#undef _CLANG_BUILTIN1_ARG
#undef _CLANG_BUILTIN2_ARG
#undef _CLANG_BUILTIN1
#undef _CLANG_BUILTIN2
#undef _CLANG_BUILTIN2_ARG_TEMPLATED
#undef _CLANG_BUILTIN2_ARG_TEMPLATED_CHAR8_T
#undef _CLANG_BUILTIN2_ARG_TEMPLATED_WCHAR_T
#undef _CLANG_BUILTIN2_TEMPLATED
#endif // ^^^ defined(__clang__) ^^^

// TRANSITION, DevCom-10294165, should be provided by UCRT
template<class _Ty, _STD enable_if_t<_STD is_integral_v<_Ty>, int> = 0>
_NODISCARD _Check_return_ _CONSTEXPR23 int fpclassify(_In_ const _Ty _Ix) noexcept /* strengthened */ {
  return _Ix == 0 ? FP_ZERO : FP_NORMAL;
}

// TRANSITION, DevCom-10294165, should be provided by UCRT
template<class _Ty, _STD enable_if_t<_STD is_integral_v<_Ty>, int> = 0>
_NODISCARD _Check_return_ _CONSTEXPR23 bool signbit(_In_ const _Ty _Ix) noexcept /* strengthened */ {
  if constexpr (static_cast<_Ty>(-1) < _Ty{}) {
    return _Ix < 0;
  } else {
    return false;
  }
}

// TRANSITION, DevCom-10294165, additional overloads are not templated to avoid ambiguity with the overload in UCRT
#define _GENERIC_MATH_ISNORMAL(TYPE)                                                                      \
  _NODISCARD _Check_return_ _CONSTEXPR23 bool isnormal(_In_ const TYPE _Ix) noexcept /* strengthened */ { \
    return _Ix != 0;                                                                                      \
  }

_GENERIC_MATH_ISNORMAL(signed char)
_GENERIC_MATH_ISNORMAL(unsigned char)
_GENERIC_MATH_ISNORMAL(short)
_GENERIC_MATH_ISNORMAL(unsigned short)
_GENERIC_MATH_ISNORMAL(int)
_GENERIC_MATH_ISNORMAL(unsigned int)
_GENERIC_MATH_ISNORMAL(long)
_GENERIC_MATH_ISNORMAL(unsigned long)
_GENERIC_MATH_ISNORMAL(long long)
_GENERIC_MATH_ISNORMAL(unsigned long long)
_GENERIC_MATH_ISNORMAL(bool)
_GENERIC_MATH_ISNORMAL(char)
#ifdef __cpp_char8_t
_GENERIC_MATH_ISNORMAL(char8_t)
#endif // defined(__cpp_char8_t)
_GENERIC_MATH_ISNORMAL(char16_t)
_GENERIC_MATH_ISNORMAL(char32_t)
#ifdef _NATIVE_WCHAR_T_DEFINED
_GENERIC_MATH_ISNORMAL(wchar_t)
#endif // defined(_NATIVE_WCHAR_T_DEFINED)
#undef _GENERIC_MATH_ISNORMAL

#define _GENERIC_MATH1_BASE(NAME, RET, FUN)                               \
  template<class _Ty, _STD enable_if_t<_STD is_integral_v<_Ty>, int> = 0> \
  _NODISCARD RET NAME(_Ty _Left) noexcept /* strengthened */ {            \
    return FUN(static_cast<double>(_Left));                               \
  }

#define _GENERIC_MATH1R(FUN, RET) _GENERIC_MATH1_BASE(FUN, RET, _CSTD FUN)
#define _GENERIC_MATH1(FUN) _GENERIC_MATH1R(FUN, double)

#if _HAS_CMATH_INTRINSICS
#define _GENERIC_MATH1I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH1_BASE(FUN, double, MSVC_INTRIN)
#elif defined(__clang__)
#define _GENERIC_MATH1I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH1_BASE(FUN, double, CLANG_INTRIN)
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
#define _GENERIC_MATH1I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH1_BASE(FUN, double, _CSTD FUN)
#endif // ^^^ intrinsics unavailable ^^^

#define _GENERIC_MATH1X(FUN, ARG2)                                           \
  template<class _Ty, _STD enable_if_t<_STD is_integral_v<_Ty>, int> = 0>    \
  _NODISCARD double FUN(_Ty _Left, ARG2 _Arg2) noexcept /* strengthened */ { \
    return _CSTD FUN(static_cast<double>(_Left), _Arg2);                     \
  }

// When the arguments are both floats or both long doubles, overload resolution prefers the
// non-template overloads to the templates generated from this macro. The templates generated from
// this macro are only selected by overload resolution when both arguments have integral type, or
// when the types of the two arguments differ, in which case _Common_float_type_t is either double
// or long double. Note that double and long double have the same underlying representation on our
// supported platforms.
#define _GENERIC_MATH2_BASE(NAME, FUN)                                                                         \
  template<class _Ty1, class _Ty2,                                                                             \
           _STD enable_if_t<_STD is_arithmetic_v<_Ty1> && _STD is_arithmetic_v<_Ty2>, int> = 0>                \
  _NODISCARD _STD _Common_float_type_t<_Ty1, _Ty2> NAME(_Ty1 _Left, _Ty2 _Right) noexcept /* strengthened */ { \
    return FUN(static_cast<double>(_Left), static_cast<double>(_Right));                                       \
  }

#define _GENERIC_MATH2(FUN) _GENERIC_MATH2_BASE(FUN, _CSTD FUN)

#if _HAS_CMATH_INTRINSICS
#define _GENERIC_MATH2I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH2_BASE(FUN, MSVC_INTRIN)
#elif defined(__clang__)
#define _GENERIC_MATH2I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH2_BASE(FUN, CLANG_INTRIN)
#else // ^^^ defined(__clang__) / intrinsics unavailable vvv
#define _GENERIC_MATH2I(FUN, CLANG_INTRIN, MSVC_INTRIN) _GENERIC_MATH2_BASE(FUN, _CSTD FUN)
#endif // ^^^ intrinsics unavailable ^^^

// TRANSITION, DevCom-10294165, additional overloads are not templated to avoid ambiguity with the overload in UCRT
#define _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, TYPE)                                             \
  _NODISCARD _Check_return_ _CONSTEXPR23 bool FUN(_In_ TYPE) noexcept /* strengthened */ { return RETV; }

#ifdef __cpp_char8_t
#define _GENERIC_MATH_CLASSIFY1_RETV_CHAR8_T(FUN, RETV) _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, char8_t)
#else // ^^^ defined(__cpp_char8_t) / !defined(__cpp_char8_t) vvv
#define _GENERIC_MATH_CLASSIFY1_RETV_CHAR8_T(FUN, RETV)
#endif // ^^^ !defined(__cpp_char8_t) ^^^

#ifdef _NATIVE_WCHAR_T_DEFINED
#define _GENERIC_MATH_CLASSIFY1_RETV_WCHAR_T(FUN, RETV) _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, wchar_t)
#else // ^^^ defined(_NATIVE_WCHAR_T_DEFINED) / !defined(_NATIVE_WCHAR_T_DEFINED) vvv
#define _GENERIC_MATH_CLASSIFY1_RETV_WCHAR_T(FUN, RETV)
#endif // ^^^ !defined(_NATIVE_WCHAR_T_DEFINED) ^^^

#define _GENERIC_MATH_CLASSIFY1_RETV(FUN, RETV)                       \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, signed char)        \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, unsigned char)      \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, short)              \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, unsigned short)     \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, int)                \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, unsigned int)       \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, long)               \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, unsigned long)      \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, long long)          \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, unsigned long long) \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, bool)               \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, char)               \
  _GENERIC_MATH_CLASSIFY1_RETV_CHAR8_T(FUN, RETV)                     \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, char16_t)           \
  _GENERIC_MATH_CLASSIFY1_RETV_INTEGER(FUN, RETV, char32_t)           \
  _GENERIC_MATH_CLASSIFY1_RETV_WCHAR_T(FUN, RETV)

// The following order matches N4950 [cmath.syn].
_GENERIC_MATH1(acos)
_GENERIC_MATH1(asin)
_GENERIC_MATH1(atan)
_GENERIC_MATH2(atan2)
_GENERIC_MATH1(cos)
_GENERIC_MATH1(sin)
_GENERIC_MATH1(tan)
_GENERIC_MATH1(acosh)
_GENERIC_MATH1(asinh)
_GENERIC_MATH1(atanh)
_GENERIC_MATH1(cosh)
_GENERIC_MATH1(sinh)
_GENERIC_MATH1(tanh)
_GENERIC_MATH1(exp)
_GENERIC_MATH1(exp2)
_GENERIC_MATH1(expm1)
// frexp() is hand-crafted
_GENERIC_MATH1R(ilogb, int)
_GENERIC_MATH1X(ldexp, int)
_GENERIC_MATH1(log)
_GENERIC_MATH1(log10)
_GENERIC_MATH1(log1p)
_GENERIC_MATH1(log2)
_GENERIC_MATH1(logb)
// No modf(), types must match
_GENERIC_MATH1X(scalbn, int)
_GENERIC_MATH1X(scalbln, long)
_GENERIC_MATH1(cbrt)
// abs() has integer overloads
_GENERIC_MATH1(fabs)
_GENERIC_MATH2(hypot)
// 3-arg hypot() is hand-crafted
_GENERIC_MATH2(pow)
_GENERIC_MATH1(sqrt)
_GENERIC_MATH1(erf)
_GENERIC_MATH1(erfc)
_GENERIC_MATH1(lgamma)
_GENERIC_MATH1(tgamma)
_GENERIC_MATH1I(ceil, __builtin_ceil, __ceil)
_GENERIC_MATH1I(floor, __builtin_floor, __floor)
_GENERIC_MATH1(nearbyint)
_GENERIC_MATH1(rint)
_GENERIC_MATH1R(lrint, long)
_GENERIC_MATH1R(llrint, long long)
_GENERIC_MATH1I(round, __builtin_round, __round)
_GENERIC_MATH1R(lround, long)
_GENERIC_MATH1R(llround, long long)
_GENERIC_MATH1I(trunc, __builtin_trunc, __trunc)
_GENERIC_MATH2(fmod)
_GENERIC_MATH2(remainder)
// remquo() is hand-crafted
_GENERIC_MATH2I(copysign, __builtin_copysign, __copysign)
// nan(const char*) is exempt
_GENERIC_MATH2(nextafter)
_GENERIC_MATH1X(nexttoward, long double)
_GENERIC_MATH2(fdim)
_GENERIC_MATH2(fmax)
_GENERIC_MATH2(fmin)
// fma() is hand-crafted
// lerp() is hand-crafted
// fpclassify() is hand-crafted
_GENERIC_MATH_CLASSIFY1_RETV(isfinite, true)
_GENERIC_MATH_CLASSIFY1_RETV(isinf, false)
_GENERIC_MATH_CLASSIFY1_RETV(isnan, false)
// isnormal() is half-hand-crafted
// signbit() is hand-crafted

#undef _GENERIC_MATH1_BASE
#undef _GENERIC_MATH1R
#undef _GENERIC_MATH1
#undef _GENERIC_MATH1I
#undef _GENERIC_MATH1X
#undef _GENERIC_MATH2_BASE
#undef _GENERIC_MATH2
#undef _GENERIC_MATH2I
#undef _GENERIC_MATH_CLASSIFY1_RETV_INTEGER
#undef _GENERIC_MATH_CLASSIFY1_RETV_WCHAR_T
#undef _GENERIC_MATH_CLASSIFY1_RETV_CHAR8_T
#undef _GENERIC_MATH_CLASSIFY1_RETV
#undef _HAS_CMATH_INTRINSICS
_END_EXTERN_CXX_WORKAROUND

_STD_BEGIN
_EXPORT_STD using _CSTD abs;
_EXPORT_STD using _CSTD acos;
_EXPORT_STD using _CSTD asin;
_EXPORT_STD using _CSTD atan;
_EXPORT_STD using _CSTD atan2;
_EXPORT_STD using _CSTD ceil;
_EXPORT_STD using _CSTD cos;
_EXPORT_STD using _CSTD cosh;
_EXPORT_STD using _CSTD exp;
_EXPORT_STD using _CSTD fabs;
_EXPORT_STD using _CSTD floor;
_EXPORT_STD using _CSTD fmod;
_EXPORT_STD using _CSTD frexp;
_EXPORT_STD using _CSTD ldexp;
_EXPORT_STD using _CSTD log;
_EXPORT_STD using _CSTD log10;
_EXPORT_STD using _CSTD modf;
_EXPORT_STD using _CSTD pow;
_EXPORT_STD using _CSTD sin;
_EXPORT_STD using _CSTD sinh;
_EXPORT_STD using _CSTD sqrt;
_EXPORT_STD using _CSTD tan;
_EXPORT_STD using _CSTD tanh;

_EXPORT_STD using _CSTD acosf;
_EXPORT_STD using _CSTD asinf;
_EXPORT_STD using _CSTD atanf;
_EXPORT_STD using _CSTD atan2f;
_EXPORT_STD using _CSTD ceilf;
_EXPORT_STD using _CSTD cosf;
_EXPORT_STD using _CSTD coshf;
_EXPORT_STD using _CSTD expf;
_EXPORT_STD using _CSTD fabsf;
_EXPORT_STD using _CSTD floorf;
_EXPORT_STD using _CSTD fmodf;
_EXPORT_STD using _CSTD frexpf;
_EXPORT_STD using _CSTD ldexpf;
_EXPORT_STD using _CSTD logf;
_EXPORT_STD using _CSTD log10f;
_EXPORT_STD using _CSTD modff;
_EXPORT_STD using _CSTD powf;
_EXPORT_STD using _CSTD sinf;
_EXPORT_STD using _CSTD sinhf;
_EXPORT_STD using _CSTD sqrtf;
_EXPORT_STD using _CSTD tanf;
_EXPORT_STD using _CSTD tanhf;

_EXPORT_STD using _CSTD acosl;
_EXPORT_STD using _CSTD asinl;
_EXPORT_STD using _CSTD atanl;
_EXPORT_STD using _CSTD atan2l;
_EXPORT_STD using _CSTD ceill;
_EXPORT_STD using _CSTD cosl;
_EXPORT_STD using _CSTD coshl;
_EXPORT_STD using _CSTD expl;
_EXPORT_STD using _CSTD fabsl;
_EXPORT_STD using _CSTD floorl;
_EXPORT_STD using _CSTD fmodl;
_EXPORT_STD using _CSTD frexpl;
_EXPORT_STD using _CSTD ldexpl;
_EXPORT_STD using _CSTD logl;
_EXPORT_STD using _CSTD log10l;
_EXPORT_STD using _CSTD modfl;
_EXPORT_STD using _CSTD powl;
_EXPORT_STD using _CSTD sinl;
_EXPORT_STD using _CSTD sinhl;
_EXPORT_STD using _CSTD sqrtl;
_EXPORT_STD using _CSTD tanl;
_EXPORT_STD using _CSTD tanhl;

_EXPORT_STD using _CSTD float_t;
_EXPORT_STD using _CSTD double_t;

_EXPORT_STD using _CSTD acosh;
_EXPORT_STD using _CSTD asinh;
_EXPORT_STD using _CSTD atanh;
_EXPORT_STD using _CSTD cbrt;
_EXPORT_STD using _CSTD erf;
_EXPORT_STD using _CSTD erfc;
_EXPORT_STD using _CSTD expm1;
_EXPORT_STD using _CSTD exp2;

inline namespace _Binary_hypot {
_EXPORT_STD using _CSTD hypot;
} // namespace _Binary_hypot

_EXPORT_STD using _CSTD ilogb;
_EXPORT_STD using _CSTD lgamma;
_EXPORT_STD using _CSTD log1p;
_EXPORT_STD using _CSTD log2;
_EXPORT_STD using _CSTD logb;
_EXPORT_STD using _CSTD llrint;
_EXPORT_STD using _CSTD lrint;
_EXPORT_STD using _CSTD nearbyint;
_EXPORT_STD using _CSTD rint;
_EXPORT_STD using _CSTD llround;
_EXPORT_STD using _CSTD lround;
_EXPORT_STD using _CSTD fdim;
_EXPORT_STD using _CSTD fma;
_EXPORT_STD using _CSTD fmax;
_EXPORT_STD using _CSTD fmin;
_EXPORT_STD using _CSTD round;
_EXPORT_STD using _CSTD trunc;
_EXPORT_STD using _CSTD remainder;
_EXPORT_STD using _CSTD remquo;
_EXPORT_STD using _CSTD copysign;
_EXPORT_STD using _CSTD nan;
_EXPORT_STD using _CSTD nextafter;
_EXPORT_STD using _CSTD scalbn;
_EXPORT_STD using _CSTD scalbln;
_EXPORT_STD using _CSTD nexttoward;
_EXPORT_STD using _CSTD tgamma;

_EXPORT_STD using _CSTD acoshf;
_EXPORT_STD using _CSTD asinhf;
_EXPORT_STD using _CSTD atanhf;
_EXPORT_STD using _CSTD cbrtf;
_EXPORT_STD using _CSTD erff;
_EXPORT_STD using _CSTD erfcf;
_EXPORT_STD using _CSTD expm1f;
_EXPORT_STD using _CSTD exp2f;
_EXPORT_STD using _CSTD hypotf;
_EXPORT_STD using _CSTD ilogbf;
_EXPORT_STD using _CSTD lgammaf;
_EXPORT_STD using _CSTD log1pf;
_EXPORT_STD using _CSTD log2f;
_EXPORT_STD using _CSTD logbf;
_EXPORT_STD using _CSTD llrintf;
_EXPORT_STD using _CSTD lrintf;
_EXPORT_STD using _CSTD nearbyintf;
_EXPORT_STD using _CSTD rintf;
_EXPORT_STD using _CSTD llroundf;
_EXPORT_STD using _CSTD lroundf;
_EXPORT_STD using _CSTD fdimf;
_EXPORT_STD using _CSTD fmaf;
_EXPORT_STD using _CSTD fmaxf;
_EXPORT_STD using _CSTD fminf;
_EXPORT_STD using _CSTD roundf;
_EXPORT_STD using _CSTD truncf;
_EXPORT_STD using _CSTD remainderf;
_EXPORT_STD using _CSTD remquof;
_EXPORT_STD using _CSTD copysignf;
_EXPORT_STD using _CSTD nanf;
_EXPORT_STD using _CSTD nextafterf;
_EXPORT_STD using _CSTD scalbnf;
_EXPORT_STD using _CSTD scalblnf;
_EXPORT_STD using _CSTD nexttowardf;
_EXPORT_STD using _CSTD tgammaf;

_EXPORT_STD using _CSTD acoshl;
_EXPORT_STD using _CSTD asinhl;
_EXPORT_STD using _CSTD atanhl;
_EXPORT_STD using _CSTD cbrtl;
_EXPORT_STD using _CSTD erfl;
_EXPORT_STD using _CSTD erfcl;
_EXPORT_STD using _CSTD expm1l;
_EXPORT_STD using _CSTD exp2l;
_EXPORT_STD using _CSTD hypotl;
_EXPORT_STD using _CSTD ilogbl;
_EXPORT_STD using _CSTD lgammal;
_EXPORT_STD using _CSTD log1pl;
_EXPORT_STD using _CSTD log2l;
_EXPORT_STD using _CSTD logbl;
_EXPORT_STD using _CSTD llrintl;
_EXPORT_STD using _CSTD lrintl;
_EXPORT_STD using _CSTD nearbyintl;
_EXPORT_STD using _CSTD rintl;
_EXPORT_STD using _CSTD llroundl;
_EXPORT_STD using _CSTD lroundl;
_EXPORT_STD using _CSTD fdiml;
_EXPORT_STD using _CSTD fmal;
_EXPORT_STD using _CSTD fmaxl;
_EXPORT_STD using _CSTD fminl;
_EXPORT_STD using _CSTD roundl;
_EXPORT_STD using _CSTD truncl;
_EXPORT_STD using _CSTD remainderl;
_EXPORT_STD using _CSTD remquol;
_EXPORT_STD using _CSTD copysignl;
_EXPORT_STD using _CSTD nanl;
_EXPORT_STD using _CSTD nextafterl;
_EXPORT_STD using _CSTD scalbnl;
_EXPORT_STD using _CSTD scalblnl;
_EXPORT_STD using _CSTD nexttowardl;
_EXPORT_STD using _CSTD tgammal;

_EXPORT_STD using _CSTD fpclassify;
_EXPORT_STD using _CSTD signbit;
_EXPORT_STD using _CSTD isfinite;
_EXPORT_STD using _CSTD isinf;
_EXPORT_STD using _CSTD isnan;
_EXPORT_STD using _CSTD isnormal;
_EXPORT_STD using _CSTD isgreater;
_EXPORT_STD using _CSTD isgreaterequal;
_EXPORT_STD using _CSTD isless;
_EXPORT_STD using _CSTD islessequal;
_EXPORT_STD using _CSTD islessgreater;
_EXPORT_STD using _CSTD isunordered;
_STD_END

#if _HAS_CXX17
extern "C" {
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_assoc_laguerre(unsigned int, unsigned int, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_assoc_laguerref(unsigned int, unsigned int, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_assoc_legendre(unsigned int, unsigned int, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_assoc_legendref(unsigned int, unsigned int, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_beta(double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_betaf(float, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_comp_ellint_1(double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_comp_ellint_1f(float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_comp_ellint_2(double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_comp_ellint_2f(float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_comp_ellint_3(double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_comp_ellint_3f(float, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_cyl_bessel_i(double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_cyl_bessel_if(float, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_cyl_bessel_j(double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_cyl_bessel_jf(float, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_cyl_bessel_k(double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_cyl_bessel_kf(float, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_cyl_neumann(double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_cyl_neumannf(float, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_ellint_1(double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_ellint_1f(float, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_ellint_2(double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_ellint_2f(float, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_ellint_3(double, double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_ellint_3f(float, float, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_expint(double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_expintf(float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_hermite(unsigned int, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_hermitef(unsigned int, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_laguerre(unsigned int, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_laguerref(unsigned int, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_legendre(unsigned int, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_legendref(unsigned int, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_riemann_zeta(double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_riemann_zetaf(float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_sph_bessel(unsigned int, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_sph_besself(unsigned int, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_sph_legendre(unsigned int, unsigned int, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_sph_legendref(unsigned int, unsigned int, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_sph_neumann(unsigned int, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_sph_neumannf(unsigned int, float) noexcept;
_NODISCARD _CRT_SATELLITE_2 double __stdcall __std_smf_hypot3(double, double, double) noexcept;
_NODISCARD _CRT_SATELLITE_2 float __stdcall __std_smf_hypot3f(float, float, float) noexcept;
} // extern "C"

_STD_BEGIN
_EXPORT_STD _NODISCARD inline double assoc_laguerre(const unsigned int _Degree, const unsigned int _Order,
                                                    const double _Value) noexcept /* strengthened */ {
  return __std_smf_assoc_laguerre(_Degree, _Order, _Value);
}

_EXPORT_STD _NODISCARD inline float assoc_laguerref(const unsigned int _Degree, const unsigned int _Order,
                                                    const float _Value) noexcept /* strengthened */ {
  return __std_smf_assoc_laguerref(_Degree, _Order, _Value);
}

_EXPORT_STD _NODISCARD inline long double assoc_laguerrel(const unsigned int _Degree, const unsigned int _Order,
                                                          const long double _Value) noexcept /* strengthened */ {
  return __std_smf_assoc_laguerre(_Degree, _Order, static_cast<double>(_Value));
}

_EXPORT_STD _NODISCARD inline double assoc_legendre(const unsigned int _Degree, const unsigned int _Order,
                                                    const double _Value) noexcept /* strengthened */ {
  return __std_smf_assoc_legendre(_Degree, _Order, _Value);
}

_EXPORT_STD _NODISCARD inline float assoc_legendref(const unsigned int _Degree, const unsigned int _Order,
                                                    const float _Value) noexcept /* strengthened */ {
  return __std_smf_assoc_legendref(_Degree, _Order, _Value);
}

_EXPORT_STD _NODISCARD inline long double assoc_legendrel(const unsigned int _Degree, const unsigned int _Order,
                                                          const long double _Value) noexcept /* strengthened */ {
  return __std_smf_assoc_legendre(_Degree, _Order, static_cast<double>(_Value));
}

_EXPORT_STD _NODISCARD inline double beta(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
  return __std_smf_beta(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float betaf(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_betaf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double betal(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_beta(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double comp_ellint_1(const double _Arg) noexcept /* strengthened */ {
  return __std_smf_comp_ellint_1(_Arg);
}

_EXPORT_STD _NODISCARD inline float comp_ellint_1f(const float _Arg) noexcept /* strengthened */ {
  return __std_smf_comp_ellint_1f(_Arg);
}

_EXPORT_STD _NODISCARD inline long double comp_ellint_1l(const long double _Arg) noexcept /* strengthened */ {
  return __std_smf_comp_ellint_1(static_cast<double>(_Arg));
}

_EXPORT_STD _NODISCARD inline double comp_ellint_2(const double _Arg) noexcept /* strengthened */ {
  return __std_smf_comp_ellint_2(_Arg);
}

_EXPORT_STD _NODISCARD inline float comp_ellint_2f(const float _Arg) noexcept /* strengthened */ {
  return __std_smf_comp_ellint_2f(_Arg);
}

_EXPORT_STD _NODISCARD inline long double comp_ellint_2l(const long double _Arg) noexcept /* strengthened */ {
  return __std_smf_comp_ellint_2(static_cast<double>(_Arg));
}

_EXPORT_STD _NODISCARD inline double comp_ellint_3(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
  return __std_smf_comp_ellint_3(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float comp_ellint_3f(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_comp_ellint_3f(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double comp_ellint_3l(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_comp_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double cyl_bessel_i(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
  return __std_smf_cyl_bessel_i(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float cyl_bessel_if(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_cyl_bessel_if(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double cyl_bessel_il(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_cyl_bessel_i(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double cyl_bessel_j(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
  return __std_smf_cyl_bessel_j(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float cyl_bessel_jf(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_cyl_bessel_jf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double cyl_bessel_jl(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_cyl_bessel_j(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double cyl_bessel_k(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
  return __std_smf_cyl_bessel_k(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float cyl_bessel_kf(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_cyl_bessel_kf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double cyl_bessel_kl(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_cyl_bessel_k(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double cyl_neumann(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
  return __std_smf_cyl_neumann(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float cyl_neumannf(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_cyl_neumannf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double cyl_neumannl(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_cyl_neumann(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double ellint_1(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
  return __std_smf_ellint_1(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float ellint_1f(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_ellint_1f(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double ellint_1l(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_ellint_1(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double ellint_2(const double _Arg1, const double _Arg2) noexcept /* strengthened */ {
  return __std_smf_ellint_2(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float ellint_2f(const float _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_ellint_2f(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double ellint_2l(const long double _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_ellint_2(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double ellint_3(const double _Arg1, const double _Arg2, const double _Arg3) noexcept
/* strengthened */ {
  return __std_smf_ellint_3(_Arg1, _Arg2, _Arg3);
}

_EXPORT_STD _NODISCARD inline float ellint_3f(const float _Arg1, const float _Arg2, const float _Arg3) noexcept
/* strengthened */ {
  return __std_smf_ellint_3f(_Arg1, _Arg2, _Arg3);
}

_EXPORT_STD _NODISCARD inline long double ellint_3l(const long double _Arg1, const long double _Arg2,
                                                    const long double _Arg3) noexcept /* strengthened */ {
  return __std_smf_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3));
}

_EXPORT_STD _NODISCARD inline double expint(const double _Arg) noexcept /* strengthened */ {
  return __std_smf_expint(_Arg);
}

_EXPORT_STD _NODISCARD inline float expintf(const float _Arg) noexcept /* strengthened */ {
  return __std_smf_expintf(_Arg);
}

_EXPORT_STD _NODISCARD inline long double expintl(const long double _Arg) noexcept /* strengthened */ {
  return __std_smf_expint(static_cast<double>(_Arg));
}

_EXPORT_STD _NODISCARD inline double hermite(const unsigned int _Arg1, const double _Arg2) noexcept /* strengthened */ {
  return __std_smf_hermite(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float hermitef(const unsigned int _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_hermitef(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double hermitel(const unsigned int _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_hermite(_Arg1, static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double laguerre(const unsigned int _Arg1, const double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_laguerre(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float laguerref(const unsigned int _Arg1, const float _Arg2) noexcept /* strengthened */ {
  return __std_smf_laguerref(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double laguerrel(const unsigned int _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_laguerre(_Arg1, static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double legendre(const unsigned int _Degree, const double _Value) noexcept
/* strengthened */ {
  return __std_smf_legendre(_Degree, _Value);
}

_EXPORT_STD _NODISCARD inline float legendref(const unsigned int _Degree, const float _Value) noexcept
/* strengthened */ {
  return __std_smf_legendref(_Degree, _Value);
}

_EXPORT_STD _NODISCARD inline long double legendrel(const unsigned int _Degree, const long double _Value) noexcept
/* strengthened */ {
  return __std_smf_legendre(_Degree, static_cast<double>(_Value));
}

_EXPORT_STD _NODISCARD inline double riemann_zeta(const double _Arg) noexcept /* strengthened */ {
  return __std_smf_riemann_zeta(_Arg);
}
_EXPORT_STD _NODISCARD inline float riemann_zetaf(const float _Arg) noexcept /* strengthened */ {
  return __std_smf_riemann_zetaf(_Arg);
}

_EXPORT_STD _NODISCARD inline long double riemann_zetal(const long double _Arg) noexcept /* strengthened */ {
  return __std_smf_riemann_zeta(static_cast<double>(_Arg));
}

_EXPORT_STD _NODISCARD inline double sph_bessel(const unsigned int _Arg1, const double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_sph_bessel(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float sph_besself(const unsigned int _Arg1, const float _Arg2) noexcept
/* strengthened */ {
  return __std_smf_sph_besself(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double sph_bessell(const unsigned int _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_sph_bessel(_Arg1, static_cast<double>(_Arg2));
}

_EXPORT_STD _NODISCARD inline double sph_legendre(const unsigned int _Arg1, const unsigned int _Arg2,
                                                  const double _Theta) noexcept
/* strengthened */ {
  return __std_smf_sph_legendre(_Arg1, _Arg2, _Theta);
}

_EXPORT_STD _NODISCARD inline float sph_legendref(const unsigned int _Arg1, const unsigned int _Arg2,
                                                  const float _Theta) noexcept
/* strengthened */ {
  return __std_smf_sph_legendref(_Arg1, _Arg2, _Theta);
}

_EXPORT_STD _NODISCARD inline long double sph_legendrel(const unsigned int _Arg1, const unsigned int _Arg2,
                                                        const long double _Theta) noexcept /* strengthened */ {
  return __std_smf_sph_legendre(_Arg1, _Arg2, static_cast<double>(_Theta));
}

_EXPORT_STD _NODISCARD inline double sph_neumann(const unsigned int _Arg1, const double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_sph_neumann(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline float sph_neumannf(const unsigned int _Arg1, const float _Arg2) noexcept
/* strengthened */ {
  return __std_smf_sph_neumannf(_Arg1, _Arg2);
}

_EXPORT_STD _NODISCARD inline long double sph_neumannl(const unsigned int _Arg1, const long double _Arg2) noexcept
/* strengthened */ {
  return __std_smf_sph_neumann(_Arg1, static_cast<double>(_Arg2));
}

#define _GENERIC_MATH_SPECIAL1(NAME)                                            \
  _EXPORT_STD template<class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0>   \
  _NODISCARD auto NAME(const _Ty _Arg) noexcept /* strengthened */ {            \
    using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>;             \
    if constexpr (is_same_v<_Common, float>) {                                  \
      return __std_smf_##NAME##f(_Arg);                                         \
    } else {                                                                    \
      return static_cast<_Common>(__std_smf_##NAME(static_cast<double>(_Arg))); \
    }                                                                           \
  }

#define _GENERIC_MATH_SPECIAL2(NAME)                                                                                 \
  _EXPORT_STD template<class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> \
  _NODISCARD auto NAME(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept /* strengthened */ {                             \
    using _Common = _Common_float_type_t<_Ty1, _Ty2>;                                                                \
    if constexpr (is_same_v<_Common, float>) {                                                                       \
      return __std_smf_##NAME##f(_Arg1, _Arg2);                                                                      \
    } else {                                                                                                         \
      return static_cast<_Common>(__std_smf_##NAME(static_cast<double>(_Arg1), static_cast<double>(_Arg2)));         \
    }                                                                                                                \
  }

#define _GENERIC_MATH_SPECIAL3(NAME)                                                                                  \
  _EXPORT_STD template<class _Ty1, class _Ty2, class _Ty3,                                                            \
                       enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0> \
  _NODISCARD auto NAME(const _Ty1 _Arg1, const _Ty2 _Arg2, const _Ty3 _Arg3) noexcept /* strengthened */ {            \
    using _Common = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>;                                     \
    if constexpr (is_same_v<_Common, float>) {                                                                        \
      return __std_smf_##NAME##f(_Arg1, _Arg2, _Arg3);                                                                \
    } else {                                                                                                          \
      return static_cast<_Common>(                                                                                    \
        __std_smf_##NAME(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3)));        \
    }                                                                                                                 \
  }

#define _GENERIC_MATH_SPECIAL_UINT1(NAME)                                                       \
  _EXPORT_STD template<class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0>                   \
  _NODISCARD auto NAME(const unsigned int _Arg1, const _Ty _Arg2) noexcept /* strengthened */ { \
    using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>;                             \
    if constexpr (is_same_v<_Common, float>) {                                                  \
      return __std_smf_##NAME##f(_Arg1, _Arg2);                                                 \
    } else {                                                                                    \
      return static_cast<_Common>(__std_smf_##NAME(_Arg1, static_cast<double>(_Arg2)));         \
    }                                                                                           \
  }

#define _GENERIC_MATH_SPECIAL_UINT2(NAME)                                                              \
  _EXPORT_STD template<class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> _NODISCARD auto NAME(    \
    const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept /* strengthened */ { \
    using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>;                                    \
    if constexpr (is_same_v<_Common, float>) {                                                         \
      return __std_smf_##NAME##f(_Arg1, _Arg2, _Arg3);                                                 \
    } else {                                                                                           \
      return static_cast<_Common>(__std_smf_##NAME(_Arg1, _Arg2, static_cast<double>(_Arg3)));         \
    }                                                                                                  \
  }

// per LWG-3234 and LWG-3693
_GENERIC_MATH_SPECIAL_UINT2(assoc_laguerre)
_GENERIC_MATH_SPECIAL_UINT2(assoc_legendre)
_GENERIC_MATH_SPECIAL2(beta)
_GENERIC_MATH_SPECIAL1(comp_ellint_1)
_GENERIC_MATH_SPECIAL1(comp_ellint_2)
_GENERIC_MATH_SPECIAL2(comp_ellint_3)
_GENERIC_MATH_SPECIAL2(cyl_bessel_i)
_GENERIC_MATH_SPECIAL2(cyl_bessel_j)
_GENERIC_MATH_SPECIAL2(cyl_bessel_k)
_GENERIC_MATH_SPECIAL2(cyl_neumann)
_GENERIC_MATH_SPECIAL2(ellint_1)
_GENERIC_MATH_SPECIAL2(ellint_2)
_GENERIC_MATH_SPECIAL3(ellint_3)
_GENERIC_MATH_SPECIAL1(expint)
_GENERIC_MATH_SPECIAL_UINT1(hermite)
_GENERIC_MATH_SPECIAL_UINT1(laguerre)
_GENERIC_MATH_SPECIAL_UINT1(legendre)
_GENERIC_MATH_SPECIAL1(riemann_zeta)
_GENERIC_MATH_SPECIAL_UINT1(sph_bessel)
_GENERIC_MATH_SPECIAL_UINT2(sph_legendre)
_GENERIC_MATH_SPECIAL_UINT1(sph_neumann)

#undef _GENERIC_MATH_SPECIAL1
#undef _GENERIC_MATH_SPECIAL2
#undef _GENERIC_MATH_SPECIAL3
#undef _GENERIC_MATH_SPECIAL_UINT1
#undef _GENERIC_MATH_SPECIAL_UINT2

_EXPORT_STD _NODISCARD inline double hypot(const double _Dx, const double _Dy, const double _Dz) noexcept
/* strengthened */ {
  return __std_smf_hypot3(_Dx, _Dy, _Dz);
}

_EXPORT_STD _NODISCARD inline float hypot(const float _Dx, const float _Dy, const float _Dz) noexcept
/* strengthened */ {
  return __std_smf_hypot3f(_Dx, _Dy, _Dz);
}

_EXPORT_STD _NODISCARD inline long double hypot(const long double _Dx, const long double _Dy,
                                                const long double _Dz) noexcept /* strengthened */ {
  return __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
}

_EXPORT_STD template<class _Ty1, class _Ty2, class _Ty3,
                     enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0>
_NODISCARD auto hypot(const _Ty1 _Dx, const _Ty2 _Dy, const _Ty3 _Dz) noexcept /* strengthened */ {
  // N4950 [cmath.syn]/3 "Sufficient additional overloads"
  // Note that this template is selected by overload resolution only when at least one
  // argument is double/long double/integral but not all three are double or long double.
  using _Common = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>; // TRANSITION, fold expressions
  const auto _Result = __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
  return static_cast<_Common>(_Result);
}

#if _HAS_CXX20
template<class _Ty>
_NODISCARD constexpr _Ty _Linear_for_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) noexcept {
  if (_STD is_constant_evaluated()) {
    auto _Smaller = _ArgT;
    auto _Larger = _ArgB - _ArgA;
    auto _Abs_smaller = _Float_abs(_Smaller);
    auto _Abs_larger = _Float_abs(_Larger);
    if (_Abs_larger < _Abs_smaller) {
      _Ty _Tmp = _Smaller;
      _Smaller = _Larger;
      _Larger = _Tmp;

      _Tmp = _Abs_smaller;
      _Abs_smaller = _Abs_larger;
      _Abs_larger = _Tmp;
    }

    if (_Abs_smaller > 1) {
      // _Larger is too large to be subnormal, so scaling by 0.5 is exact, and the product _Smaller * _Larger is
      // large enough that if _ArgA is subnormal, it will be too small to contribute anyway and this way can
      // sometimes avoid overflow problems.
      return 2 * (_Ty{0.5} * _ArgA + _Smaller * (_Ty{0.5} * _Larger));
    } else {
      return _ArgA + _Smaller * _Larger;
    }
  }

  return _STD fma(_ArgT, _ArgB - _ArgA, _ArgA);
}

template<class _Ty> _NODISCARD constexpr _Ty _Common_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) noexcept {
  // on a line intersecting {(0.0, _ArgA), (1.0, _ArgB)}, return the Y value for X == _ArgT

  const bool _T_is_finite = _Is_finite(_ArgT);
  if (_T_is_finite && _Is_finite(_ArgA) && _Is_finite(_ArgB)) {
    // 99% case, put it first; this block comes from P0811R3
    if ((_ArgA <= 0 && _ArgB >= 0) || (_ArgA >= 0 && _ArgB <= 0)) {
      // exact, monotonic, bounded, determinate, and (for _ArgA == _ArgB == 0) consistent:
      return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
    }

    if (_ArgT == 1) {
      // exact
      return _ArgB;
    }

    // exact at _ArgT == 0, monotonic except near _ArgT == 1, bounded, determinate, and consistent:
    const auto _Candidate = _Linear_for_lerp(_ArgA, _ArgB, _ArgT);
    // monotonic near _ArgT == 1:
    if ((_ArgT > 1) == (_ArgB > _ArgA)) {
      if (_ArgB > _Candidate) { return _ArgB; }
    } else {
      if (_Candidate > _ArgB) { return _ArgB; }
    }

    return _Candidate;
  }

  if (_STD is_constant_evaluated()) {
    if (_Is_nan(_ArgA)) { return _ArgA; }

    if (_Is_nan(_ArgB)) { return _ArgB; }

    if (_Is_nan(_ArgT)) { return _ArgT; }
  } else {
    // raise FE_INVALID if at least one of _ArgA, _ArgB, and _ArgT is signaling NaN
    if (_Is_nan(_ArgA) || _Is_nan(_ArgB)) { return (_ArgA + _ArgB) + _ArgT; }

    if (_Is_nan(_ArgT)) { return _ArgT + _ArgT; }
  }

  if (_T_is_finite) {
    // _ArgT is finite, _ArgA and/or _ArgB is infinity
    if (_ArgT < 0) {
      // if _ArgT < 0:     return infinity in the "direction" of _ArgA if that exists, NaN otherwise
      return _ArgA - _ArgB;
    } else if (_ArgT <= 1) {
      // if _ArgT == 0:    return _ArgA (infinity) if _ArgB is finite, NaN otherwise
      // if 0 < _ArgT < 1: return infinity "between" _ArgA and _ArgB if that exists, NaN otherwise
      // if _ArgT == 1:    return _ArgB (infinity) if _ArgA is finite, NaN otherwise
      return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
    } else {
      // if _ArgT > 1:     return infinity in the "direction" of _ArgB if that exists, NaN otherwise
      return _ArgB - _ArgA;
    }
  } else {
    // _ArgT is an infinity; return infinity in the "direction" of _ArgA and _ArgB if that exists, NaN otherwise
    return _ArgT * (_ArgB - _ArgA);
  }
}

_EXPORT_STD _NODISCARD constexpr inline float lerp(const float _ArgA, const float _ArgB, const float _ArgT) noexcept {
  return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

_EXPORT_STD _NODISCARD constexpr inline double lerp(const double _ArgA, const double _ArgB,
                                                    const double _ArgT) noexcept {
  return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

_EXPORT_STD _NODISCARD constexpr inline long double lerp(const long double _ArgA, const long double _ArgB,
                                                         const long double _ArgT) noexcept {
  return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

_EXPORT_STD template<class _Ty1, class _Ty2, class _Ty3>
requires is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>
_NODISCARD constexpr auto lerp(const _Ty1 _ArgA, const _Ty2 _ArgB, const _Ty3 _ArgT) noexcept {
  using _Tgt = conditional_t<_Is_any_of_v<long double, _Ty1, _Ty2, _Ty3>, long double, double>;
  return _Common_lerp(static_cast<_Tgt>(_ArgA), static_cast<_Tgt>(_ArgB), static_cast<_Tgt>(_ArgT));
}
#endif // _HAS_CXX20
_STD_END
#endif // _HAS_CXX17

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _CMATH_
